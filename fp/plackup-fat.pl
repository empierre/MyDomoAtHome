
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Domo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOMO';
  package Domo;
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  # Author: epierre <epierre@e-nef.com>
  
  use Dancer ':syntax';
  use File::Slurp;
  use File::Spec;
  use LWP::UserAgent;
  use Crypt::SSLeay;
  use utf8;
  use Encode qw/ encode decode /;
  use Time::Piece;
  use DateTime;
  use feature     qw< unicode_strings >;
  use POSIX qw(ceil);
  #use JSON;
  use warnings;
  use strict;
  use Audio::MPD;
  
  
  our $VERSION = '0.12';
  set warnings => 0;
  my %device_tab;
  my %device_list;
  my $last_version;    #last version in github
  my $last_version_dt; # last version text in github
  
  
  hook(
     after_serializer => sub {
         my $response = shift;
         $response->{encoded} = 1;
     }
  );
  
  set serializer => 'JSON'; 
  set 'database'     => File::Spec->catfile( config->{domo_db});
  prefix undef;
  
  my $mpd_host=config->{volumio_path};
  my $mpd;
  
  get '/' => sub {
      template 'index';
  };
  
  get '/rooms' => sub {
         #Room list
    return {"rooms" => [ 
  		{ "id"=> "Switches", "name"=> "Switches" },
  		{ "id"=> "Scenes", "name"=> "Scenes" },
  		{ "id"=> "Temp", "name"=> "Weather" },
  		{ "id"=> "Utility", "name"=> "Utility" },
  #		{ "id"=> "Volumio", "name"=> "Volumio" },
  			]};
  };
  
  get '/system' => sub {
   return {"id"=> "MyDomoAtHome","apiversion"=> 1};
  };
  
  get '/devices/:deviceId/:paramKey/histo/:startdate/:enddate' => sub {
  	my $deviceId = params->{deviceId};
  	my $paramKey = params->{paramKey}||"";
  	my $startdate = params->{startdate}||"";
  	my $enddate = params->{enddate}||"";
  
  	my $type=lc(&getDeviceType($deviceId));
  	my $ptype=$type;
  debug("TYPE:$type\n");
  	if (($type eq "lux")||($type eq "energy")) {$type="counter";}
  	if ($type eq "air quality") {$type="counter";}
  	if (($ptype eq "general")) {$type="Percentage";}
  	if (($paramKey eq "hygro")) {$type="temp";}
  	if (($paramKey eq "temp")) {$type="temp";}
  
  	my $feed={ "values" => []};
  	my $url=config->{domo_path}."/json.htm?type=graph&sensor=$type&idx=$deviceId&range=day";
  	my $decoded;
  	my @results=();
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			my $f={};
  			foreach $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"d"},"%Y-%m-%d %H:%M:%SS");
  					#print $dt->epoch." \n";
  					if ((($paramKey eq "temp")&&($f->{"te"}))||($type eq "temp")) {
  							my $value=$f->{"te"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ((($paramKey eq "hygro")&&($f->{"hu"}))||($type eq "Humidity")) {
  							my $value=$f->{"hu"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($ptype eq "air quality")) {
  							my $value=$f->{"co2"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($type eq "counter")||($type eq "Percentage")) {
  							my $value=$f->{"v"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"mm"}) {
  						my $value=$f->{"mm"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"uvi"}) {
  						my $value=$f->{"uvi"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"v"}) {
  						my $value=$f->{"v"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"sp"}) {
  						my $value=$f->{"sp"};
  						my $date=$dt->epoch*1000;
  						my $feeds={"date" => "$date", "value" => "$value"};
  						push (@{$feed->{'values'}}, $feeds );
  					}
  					#di direction
  					#gu gust
  					#v counter percentage
  					#
  				}
  			return to_json($feed, { utf8 => 1} );
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false};
  		}
  	} else {
  		status 'error';
  		return { success => false};
  	}
  };
  
  get '/devices/:deviceId/action/:actionName/?:actionParam?' => sub {
  my $deviceId = params->{deviceId};
  my $actionName = params->{actionName};
  my $actionParam = params->{actionParam}||"";
  
  if ($actionName eq 'setStatus') {
  debug("actionParam=".$actionParam."\n");
          #setStatus	0/1
  	my $action;
  	if ($actionParam) {
  		$action="On";
  	} else {
  		$action="Off";
  	}
  	my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=$action&level=0&passcode=";
  debug($url);
  	my $browser = LWP::UserAgent->new;
  	my $response = $browser->get($url);
  	if ($response->is_success){ 
  		return { success => true};
  	} else {
  		status 'error';
  		return { success => false, errormsg => $response->status_line};
  	}
  } elsif ($actionName eq 'setArmed') {
  	#setArmed	0/1
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'setAck') {
  	#setAck	
  		my $url=config->{domo_path}."/json.htm?type=command&param=resetsecuritystatus&idx=$deviceId&switchcmd=Normal";
  	debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  } elsif ($actionName eq 'setLevel') {
  	#/json.htm?type=command&param=switchlight&idx=&switchcmd=Set%20Level&level=6
  	my $url;
  	if (($device_tab{$deviceId}->{"Action"}==2)or($device_tab{$deviceId}->{"Action"}==3)) {
  		if ($actionParam eq "100") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  		} else {
  			my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  		}
  	} elsif (($device_tab{$deviceId}->{"Action"}==5)) {
  		#Blinds inverted
  		if ($actionParam eq "100") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  		} else {
  			my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  		}
  	} elsif (($device_tab{$deviceId}->{"Action"}==6)) {
  		#Blinds -> On for Closed, Off for Open 
  		if ($actionParam eq "100") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=0&passcode=";
  		} else {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  		}
  	} else {
  		if ($actionParam eq "1") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$actionParam&passcode=";
  		} elsif ($actionParam eq "0") {
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  
  		} else {
  			my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  			$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Set%20Level&level=$setLevel&passcode=";
  		}
  	}
  
  	debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  	} elsif ($actionName eq 'stopShutter') {
  		#stopShutter (Venetian store)
  		my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Stop&level=0&passcode=";
  debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  		return { success => true};
  	} elsif ($actionName eq 'pulseShutter') {
  		#pulseShutter	up/down
  		status 'error';
  		return { success => false, errormsg => "not implemented"};
  	} elsif ($actionName eq 'setSetPoint') {
  		#DevThermostat
  		my $url=config->{domo_path}."/json.htm?type=setused&idx=$deviceId&used=true&setpoint=$actionParam";
  debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  		return { success => true};
  	} elsif ($actionName eq 'launchScene') {
  		#launchScene
  		#/json.htm?type=command&param=switchscene&idx=&switchcmd=
  		my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$deviceId&switchcmd=On&passcode=";
  	debug($url);
  		my $browser = LWP::UserAgent->new;
  		my $response = $browser->get($url);
  		if ($response->is_success){ 
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false, errormsg => $response->status_line};
  		}
  		return { success => true};
  	} elsif ($actionName eq 'setColor') {
  			my $url=config->{domo_path}."/json.htm?type=command&param=setcolorbrightnessvalue&idx=$deviceId&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  	} elsif ($actionName eq 'setChoice') {
  		if ($deviceId=~/^S/) {
  			my ($sc)=$deviceId=~/S(\d+)/;
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$sc&switchcmd=$actionParam&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  		} elsif ($deviceId=~/^V/) {
  			my ($sc)=$deviceId=~/V(\d+)/;
  			if ($actionParam eq "play") {
  				$mpd->play;
  			}elsif ($actionParam eq "pause") {
  				$mpd->pause;
  			}elsif ($actionParam eq "stop") {
  				$mpd->stop;
  			}elsif ($actionParam eq "next") {
  				$mpd->next;
  			}elsif ($actionParam eq "prev") {
  				$mpd->next;
  			}elsif ($actionParam eq "volumeUP") {
  				$mpd->volume("+1");
  			}elsif ($actionParam eq "volumeDOWN") {
  				$mpd->volume("-1");
  			}
  		} else {
  			status 'error';
  			return { success => false, errormsg => "not implemented"};
  		}
  	} elsif ($actionName eq 'setMode') {
  		#setChoice string
  		status 'error';
  		return { success => false, errormsg => "not implemented"};
      } else {
          status 'not_found';
          return "What?";
     }
  };
  
  get '/devices' => sub {
  	my $feed={ "devices" => []};
  	my $t_unit="°C";
  	my $system_url = config->{domo_path}."/json.htm?type=devices&filter=all&used=true&order=Name";
  	my $decoded;
  	my @results;
  	my @unk_dev;         # list of unknown devices
  debug($system_url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			#Own device version
  			my $feeds={"id" => "S0", "name" => "MyDomoAtHome", "type" => "DevGenericSensor",  params =>[]};
  			my $ver="$VERSION";
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  			#Check for new version
  			my @and=&getLastVersion();
  			my $an1;my $an2;
  			if (($ver ne $and[0])&&($and[0] ne "err")) {
  				my $feeds={"id" => "S1", "name" => "New version found", "type" => "DevGenericSensor",  params =>[]};
  				$an1=$and[0];
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$an1", "unit"=> "", "graphable" => "false"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  			#
  			#Parse the devices tree
  			#
  			foreach my $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  					my $name=$f->{"Name"};
  					#$name=~s/\s/_/;
  					#$name=~s/\s/_/;
  					#$name=~s/\//_/; 
  					$name=~s/%/P/;
  				 if ($f->{"SwitchType"}) {			
  					#print $f->{"idx"} . " " . $f->{"Name"} . " " . $f->{"Status"} . $f->{"LastUpdate"}."\n";
  					#$name.="_E";
  					my $bl=$f->{"Status"};my $rbl;
  					if ($bl eq "On") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Off") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Panic") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					elsif ($bl eq "Normal") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					else { $rbl=$bl;}
  
  					if (((($f->{"SwitchType"} eq "On/Off")||($f->{"SwitchType"} eq "Lighting Limitless/Applamp"))and($f->{"SubType"} ne "RGBW"))or($f->{"SwitchType"} eq "Contact")or($f->{"SwitchType"} eq "Dusk Sensor")) {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Push On Button")or($f->{"SwitchType"} eq "Push Off Button")) {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  						if ($f->{"SwitchType"} eq "Push Off Button") {$rbl="0"};
  						if ($f->{"SwitchType"} eq "Push On Button") {$rbl="1"};
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						#push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"1"} );
  						#push (@{$feeds->{'params'}}, {"key" => "Level", "value" =>"$rbl"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SubType"} eq "RGBW")) {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRGBLight", "room" => "Switches", params =>[]};
  						if ($rbl=~/Set Level/) {$rbl=1;
  							$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  							push (@{$feeds->{'params'}}, {"key" => "dimmable", "value" => "1" } );
  							push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  						}
  
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Dimmer")||($f->{"SwitchType"} eq "Doorbell")) {
  						#DevDimmer	Dimmable light
  						#Status	Current status : 1 = On / 0 = Off	N/A
  						#Level	Current dim level (0-100)	%
  						#"idx" : "3", "Name" : "Alerte",  "Level" : 0,  "SwitchType" : "Dimmer",  "Status" : "Off","LastUpdate" : "2014-03-18 22:17:18"
  						if ($rbl=~/Set Level/) {$rbl=1;}
  						$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDimmer", "room" => "Switches", params =>[]};
  
  						push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Blinds Inverted") {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=5;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=5;};
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Unknown")||($f->{"SwitchTypeVal"} eq "16")) {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v=$f->{"Level"};
  
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Blinds Percentage") {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=$f->{"Level"}};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Blinds")&&($f->{"SubType"} ne "RollerTrol, Hasta new")) {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"SwitchType"} eq "Venetian Blinds EU")||($f->{"SwitchType"} eq "Venetian Blinds US")||($f->{"SubType"} eq "RollerTrol, Hasta new")) {
  						#DevShutter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  						my $v;
  						if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  						my $bl=$f->{"Status"};my $rbl;
  						if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  						elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  						push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"1"} );
  						push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  						push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Motion Sensor") {
  						#DevMotion	Motion security sensor
  						#Status	CM180 status : 1 = On / 0 = Off	N/A
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevMotion", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"SwitchType"} eq "Door Lock") {
  						#DevLock	Door / window lock
  						#Status	CM180 status : 1 = On / 0 = Off	N/A
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDoor", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						push (@{$feed->{'devices'}}, $feeds );
  					}elsif ($f->{"SwitchType"} eq "Smoke Detector") {
  						#DevSmoke	Smoke security sensor
  						#Armable	Ability to arm the device : 1 = Yes / 0 = No	N/A
  						#Ackable	Ability to acknowledge alerts : 1 = Yes / 0 = No	N/A
  						#Armed	Current arming status : 1 = On / 0 = Off	N/A
  						#Tripped	Is the sensor tripped ? (0 = No - 1 = Tripped)	N/A				
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSmoke", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						if ($f->{"Type"} eq "Security") {
  							push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "1" } );
  						} else {
  							push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						}
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						#"GET http://192.168.0.24:8080/json.htm?type=command&param=resetsecuritystatus&idx=202&switchcmd=Normal"
  						push (@{$feed->{'devices'}}, $feeds );				
  					}
  					#DevDoor	Door / window security sensor
  					#DevFlood	Flood security sensor
  					#DevCO2Alert	CO2 Alert sensor	
  				} else {
  					if ((($f->{"Type"} eq "P1 Smart Meter") and ($f->{"SubType"} eq "Energy")) or (($f->{"Type"} eq "YouLess Meter") and ($f->{"SubType"} eq "YouLess counter")) ) {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						my $usage;
  						if ($f->{"Usage"}) {
  							($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  						} elsif ($f->{"Counter"}) {
  							($usage)= ($f->{"Counter"} =~ /(\d+) Watt/);
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  						}
  						my ($total)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif (($f->{"Type"} eq "P1 Smart Meter") and ($f->{"SubType"} eq "Gas"))  {
  						# (Dutch)P1 Gas Meter
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  						my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "m3"} );
  						push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "m3"} );
  						push (@{$feed->{'devices'}}, $feeds );
  						
  						# Generic Sensor showing today's value
  						my ($usage_today)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$feeds={"id" => $f->{"idx"}."_today", "name" => $name."_today", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage_today", "unit"=> "m3", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Energy") {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						#if ($f->{"Usage"}) {
  							my $usage;
  							($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  							if (!$usage) {$usage="0";}
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W"} );#}
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Usage") {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#"Type" : "Usage", "SubType" : "Electric", "Data" : "122.3 Watt"
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$total", "unit" => "W"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Current/Energy") {
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my ($L1,$L2,$L3,$tot)= split(/,/,$f->{"Data"});
  						my ($l1)= ($L1 =~ /(\d+) Watt/);
  						my ($l2)= ($L2 =~ /(\d+) Watt/);
  						my ($l3)= ($L3 =~ /(\d+) Watt/);
  						if ($l1) {	
  							my $feeds={"id" => $f->{"idx"}."_L1", "name" => $name." L1", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l1", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l2) {	
  							my $feeds={"id" => $f->{"idx"}."_L2", "name" => $name." L2", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l2", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l3) {	
  							my $feeds={"id" => $f->{"idx"}."_L3", "name" => $name." L3", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l3", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  					}  elsif (($f->{"Type"} =~ "Temp")||($f->{"Type"} =~ "Humidity"))  {
  						if (($f->{"Type"} =~ "Temp")&&($f->{"Type"} =~ "Humidity")) {
  							my $feeds;
  							$feeds={params =>[],"room" => "Temp","type" => "DevTempHygro","name" => $name, "id" => $f->{"idx"}};
  
  							my $v=$f->{"Temp"};
  							push (@{$feeds->{'params'}}, {"key" => "temp", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  							my $vh=$f->{"Humidity"};
  							push (@{$feeds->{'params'}}, {"key" => "hygro", "value" => "$vh", "unit" => "%", "graphable" => "true" });
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"Type"} eq "Temp") {
  							#DevTemperature Temperature sensor
  							#Value  Current temperature     *C
  							#"Temp" : 21.50,  "Type" : "Temp + Humidity" / Type" : "Temp",
  							$device_tab{$f->{"idx"}}->{"graph"} = 'te';
  							my $feeds;
  							$feeds={params =>[],"room" => "Temp","type" => "DevTemperature","name" => $name, "id" => $f->{"idx"}};
  							my $v=$f->{"Temp"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"Type"} eq "Humidity") {
  							#DevHygrometry  Hygro sensor
  							#Value  Current hygro value     %
  							# "Humidity" : 52  "Type" : "Temp + Humidity" / Type" : "Humidity",
  							$device_tab{$f->{"idx"}}->{"graph"} = 'hu';
  
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevHygrometry", "room" => "Temp", params =>[]};
  							my $v=$f->{"Humidity"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true" });
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  					 	if ($f->{"Type"} =~ "Baro") {
  							#DevPressure    Pressure sensor
  							#Value  Current pressure        mbar
  							#"Barometer" : 1022, "Type" : "Temp + Humidity + Baro"
  							my $idx=$f->{"idx"};
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							if ($f->{"Type"} eq "Temp + Humidity + Baro") {$idx=$idx."_1"};
  							my $feeds={"id" => $idx, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  							my $v=$f->{"Barometer"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar"} );
  								push (@{$feed->{'devices'}}, $feeds );
  						}
  					}  elsif ($f->{"Type"} eq "Rain")  {
  						#DevRain        Rain sensor
  						#Value  Current instant rain value      mm/h
  						#Accumulation   Total rain accumulation mm
  						#"Rain" : "0.0", "RainRate" : "0.0", "Type" : "Rain"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'mm';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRain", "room" => "Temp", params =>[]};
  						my $v0=$f->{"RainRate"};
  						my $v1=$f->{"Rain"};
  						push (@{$feeds->{'params'}}, {"key" => "Accumulation", "value" => "$v1", "unit" => "mm", "graphable" => "true"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v0", "unit" => "mm/h"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "UV")  {
  						#DevUV  UV sensor
  						#Value  Current UV index        index
  						# "Type" : "UV","UVI" : "6.0"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevUV", "room" => "Temp", params =>[]};
  						my $v=$f->{"UVI"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Lux")  {
  						#DevLux  Lux sensor
  						#Value  Current Lux value        index
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevLuminosity", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) Lux/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Air Quality")  {
  						#DevCO2  CO2 sensor
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevCO2", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) ppm/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "ppm", "graphable" => "true"});
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "Wind")  {
  						#DevWind wind
  						$device_tab{$f->{"idx"}}->{"graph"} = 'sp';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevWind", "room" => "Temp", params =>[]};
  						my ($dir)=($f->{"Direction"}=~/(\d+)/);
  						my ($speed)=($f->{"Speed"}=~/(\d+)/);
  						push (@{$feeds->{'params'}}, {"key" => "Speed", "value" => "$speed", "unit" => "km/h", "graphable" => "true"});
  						push (@{$feeds->{'params'}}, {"key" => "Direction", "value" => "$dir", "unit" => "°"});
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($f->{"Type"} eq "RFXMeter")  {
  						if ($f->{"SwitchTypeVal"} eq "1") {
  							#Gas
  							my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  							my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  							$total=ceil($total);
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$usage, "unit" => "m3"} );
  							 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>$total, "unit" => "m3"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SwitchTypeVal"} eq "2") {
  							#Water
  							my ($usage)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  							my ($total)= ($f->{"Counter"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							my $totalm3=ceil($total);
  							my $usagem3=ceil($usage/1000);
  							my $feeds={"id" => $f->{"idx"}, "name" => "$name", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usagem3", "unit" => "m3", "graphable" => "true"} );
  							 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$totalm3", "unit" => "m3"} );
  							push (@{$feed->{'devices'}}, $feeds );
  							#Water by liter
  							my $usage2=$usage; #move to liters
  							$feeds={"id" => $f->{"idx"}."_l", "name" => $name."_l", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage2", "unit"=> "L"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif (($f->{"SwitchTypeVal"} eq "3")||($f->{"SubType"} eq "RFXMeter counter")) {
  							#Counter
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							my ($v)=($f->{"Counter"}=~/^([^\s]+)/);
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" => "$v"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} else {
  							push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}
  					} elsif ($f->{"Type"} eq "General")  {
  							if ($f->{"SubType"} eq "Percentage") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Voltage") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "V"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "kWh") {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						my $usage;
  						($usage)= ($f->{"Usage"} =~ /^(\d+\.\d+) Watt/);
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "kWh", "graphable" => "false"} );
  						push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Pressure") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar", "graphable" => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Visibility") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "km"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Solar Radiation") {
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "Watt/m2"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif (($f->{"SubType"} eq "Text")||($f->{"SubType"} eq "Alert")||($f->{"SubType"} eq "Unknown")) {	   
  	    						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  							my $v= $f->{"Data"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => ""} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} elsif ($f->{"SubType"} eq "Sound Level") {	   
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							my ($v)= ($f->{"Data"} =~ /^([0-9]+) dB/);
  	    						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevNoise", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "dB", graphable => "true"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} else { 
  							push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}
  					} elsif (($f->{"SubType"})&&($f->{"SubType"} eq "SetPoint")) {
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevThermostat", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"SetPoint"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "cursetpoint", "value" => "$v"});
  							push (@{$feeds->{'params'}}, {"key" => "curtemp", "value" => "$v", "unit"=>$t_unit} );
  							push (@{$feeds->{'params'}}, {"key" => "step", "value" => "0.5"} );
  							push (@{$feeds->{'params'}}, {"key" => "curmode", "value" => "default"} );
  							push (@{$feeds->{'params'}}, {"key" => "availablemodes", "value" => "default"} );
  							push (@{$feed->{'devices'}}, $feeds );
  					} else {
  						#catchall
  						if ($f->{"idx"}>5) {push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};}					}
  				}
  			}; 
  		}
  
  		#Unknown device list
  		my $ind_unk=2;
  		foreach my $devt ( @unk_dev)  {
  			my $feeds={"id" => "S".$ind_unk++, "name" => "$devt", "type" => "DevGenericSensor", "room" => "noroom", params =>[]};
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"unk", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  		}
  	} else {
  		my $feeds={"id" => "S00", "name" => "Unable to connect to Domoticz", "type" => "DevGenericSensor",  params =>[]};
  		my $ver=config->{domo_path};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  		$feeds={"id" => "S01", "name" => "Please add this gateway in Setup/settings/Local Networks", "type" => "DevGenericSensor",  params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#MPD
  	if ($mpd_host ne '') {
  		$mpd=Audio::MPD->new ( host => $mpd_host);
  	}
  	#Status
  	if ($mpd_host) {
  		my $status = $mpd->status;
  		my $song = $mpd->current;
  		my $feeds={"id" => "V2", "name" => $song->artist." - ".$song->album, "type" => "DevMultiSwitch", "room" => "Volumio", params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>$status->state, "unit"=> "", "graphable" => "false"} );
  		push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "play,stop,pause,next,prev,volumeUP,volumeDOWN"});
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#Get Scenes
  	$system_url=config->{domo_path}."/json.htm?type=scenes";
  	$json = $ua->get( $system_url );
  	#warn "Could not get $system_url!" unless defined $json;
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  	#	debug($dt->strftime("%Y-%m-%d %H:%M:%S"));
  					my $name=$f->{"Name"};
  					$name=~s/%/P/;
  					#DevScene       Scene (launchable)
  					#LastRun        Date of last run        N/A
  					#"idx" : "3", "Name" : "Alerte", "Type" : "Scenes", "LastUpdate" : "2014-03-18 22:17:18"
  					if ($f->{"Type"} eq "Group") {
  						my $feeds={"id" => "S".$f->{"idx"}, "name" => $name, "type" => "DevMultiSwitch", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => $f->{"Status"}} );
  						push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "Mixed,On,Off"} );
  						push (@{$feed->{'devices'}}, $feeds );
  
  					} else {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevScene", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  			}
  		}
  	}
  	#Get Camera
  	$system_url=config->{domo_path}."/json.htm?type=cameras";
  debug($system_url);
  	$json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $name=$f->{"Name"};
  					$name=~s/\s/_/;
  					$name=~s/\s/_/;
  					$name=~s/\//_/;
  					$name=~s/%/P/;
  					my $feeds={"id" => $f->{"idx"}."_cam", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  					my $v=$f->{"ImageURL"};my $v2=config->{external_url_camera};my $v3=$f->{"VideoURL"};
  					if ($v =~ /^http/) {
  						push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  					} else {
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  						} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  	
  						}
  					}
  					if ($v2) {push (@{$feeds->{'params'}}, {"key" => "remotejpegurl", "value" => "$v2"} );}
  					push (@{$feed->{'devices'}}, $feeds );
  					# Now if VideoURL
  					if ($v3) {
  						my $feeds2={"id" => $f->{"idx"}."_video", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							}
  						push (@{$feed->{'devices'}}, $feeds2 );
  						}
  			}
  		}
  	}
  	#DevGenericSensor      Generic sensor (any value)
  	#Value  Current value   N/A
  
  
  	
  	return to_json($feed, { utf8 => 1} );
  	return { success => true};
  };
  
  sub getDeviceType($) {
  	my ($deviceId)=@_;
  	my $url=config->{domo_path}."/json.htm?type=devices&rid=$deviceId";
  	my $decoded;
  	my @results;
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  				if ($f->{SubType} eq "RFXMeter counter") {
  					return("counter");
  				} else {
  					return($f->{Type});
  				}
  			}
  		}
  	}
  }
  sub getLastVersion() {
  	my $dt = DateTime->now();
  	if ($last_version_dt < $dt->add( hours => 4 )) {
  		my @res;
  		push @res,$last_version;
  		push @res,"";
  		return(@res);
  	} else {
  		my $url="https://api.github.com/repos/empierre/MyDomoAtHome/releases/latest";
  		my $decoded;
  		my @results;
  	debug($url);
  		my $ua = LWP::UserAgent->new();
  		$ua->agent("MyDomoREST/$VERSION");
  		my $json = $ua->get( $url );
  		if ($json->is_success) {
  			# Decode the entire JSON
  			$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  			if ($decoded) {
  				my @res;
  				push @res,$decoded->{tag_name};
  				push @res,$decoded->{body};
  				$last_version_dt=DateTime->now;
  				$last_version=$decoded->{tag_name};
  				return(@res);
  			}
  		} else {return "err";}
  	}
  }
  1;
DOMO

$fatpacked{"Domo2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOMO2';
  package Domo2;
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  # Author: epierre <epierre@e-nef.com>
  use Dancer2 appname => 'Domo';
  use File::Slurp;
  use File::Spec;
  use DateTime;
  use LWP::UserAgent;
  use Crypt::SSLeay;
  use utf8;
  use Encode qw/ encode decode /;
  use Time::Piece;
  use feature     qw< unicode_strings >;
  use POSIX qw(ceil);
  use Audio::MPD;
  use Switch;
  use Plack::Builder;
  use warnings;
  use strict;
  
  our $VERSION = '0.13';
  set warnings => 0;
  my %device_tab;
  my %room_tab;
  my %device_list;
  my $last_version;    #last version in github
  my $last_version_dt; # last version text in github
  
  set serializer => 'JSON'; 
  set 'database'     => File::Spec->catfile( config->{domo_db});
  prefix undef;
  
  my $mpd_host=config->{volumio_path};
  my $mpd;
  
  get '/' => sub {
      template 'index2';
  };
  
  get '/rooms' => sub {
      #Room list
  	my @room={};
  	my $feed={ "rooms" => []};
  	foreach my $key (keys %room_tab) {
  		print "ROOM: $key\n";
  		push (@{$feed->{'rooms'}}, { "id"=> "$key", "name"=> "$key" });	 
  	}
  	return($feed);
  
  };
  
  get '/system' => sub {
   return {"id"=> "MyDomoAtHome","apiversion"=> 1};
  };
  
  get '/devices/:deviceId/:paramKey/histo/:startdate/:enddate' => sub {
  	my $deviceId = params->{deviceId};
  	my $paramKey = params->{paramKey}||"";
  	my $startdate = params->{startdate}||"";
  	my $enddate = params->{enddate}||"";
  
  	my $type=lc(&getDeviceType($deviceId));
  	my $ptype=$type;
  debug("TYPE:$type\n");
  	if (($type eq "lux")||($type eq "energy")) {$type="counter";}
  	if ($type eq "air quality") {$type="counter";}
  	if (($ptype eq "general")) {$type="Percentage";}
  	if (($paramKey eq "hygro")) {$type="temp";}
  	if (($paramKey eq "temp")) {$type="temp";}
  
  	my $feed={ "values" => []};
  	my $url=config->{domo_path}."/json.htm?type=graph&sensor=$type&idx=$deviceId&range=day";
  	my $decoded;
  	my @results=();
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			my $f={};
  			foreach $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"d"},"%Y-%m-%d %H:%M:%SS");
  					#print $dt->epoch." \n";
  					if ((($paramKey eq "temp")&&($f->{"te"}))||($type eq "temp")) {
  							my $value=$f->{"te"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ((($paramKey eq "hygro")&&($f->{"hu"}))||($type eq "Humidity")) {
  							my $value=$f->{"hu"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($ptype eq "air quality")) {
  							my $value=$f->{"co2"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif (($type eq "counter")||($type eq "Percentage")) {
  							my $value=$f->{"v"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"mm"}) {
  							my $value=$f->{"mm"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"uvi"}) {
  							my $value=$f->{"uvi"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"v"}) {
  							my $value=$f->{"v"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					} elsif ($f->{"sp"}) {
  							my $value=$f->{"sp"};
  							my $date=$dt->epoch*1000;
  							my $feeds={"date" => "$date", "value" => "$value"};
  							push (@{$feed->{'values'}}, $feeds );
  					}
  					#di direction
  					#gu gust
  					#v counter percentage
  					#
  				}
  			return to_json($feed, { utf8 => 1} );
  			return { success => true};
  		} else {
  			status 'error';
  			return { success => false};
  		}
  	} else {
  		status 'error';
  		return { success => false};
  	}
  };
  
  get '/devices/:deviceId/action/:actionName/?:actionParam?' => sub {
  	my $deviceId = params->{deviceId};
  	my $actionName = params->{actionName};
  	my $actionParam = params->{actionParam}||"";
  
  	switch($actionName) {
  		case "setStatus" {
  			debug("actionParam=".$actionParam."\n");
  			#setStatus	0/1
  			my $action;
  			if ($actionParam) {
  				$action="On";
  			} else {
  				$action="Off";
  			}
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=$action&level=0&passcode=";
  			debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  		}
  		case "setArmed" {
  			#setArmed	0/1
  			status 'error';
  			return { success => false, errormsg => "not implemented"};
  		}
  		case "setAck" {
  			#setAck	
  			my $url=config->{domo_path}."/json.htm?type=command&param=resetsecuritystatus&idx=$deviceId&switchcmd=Normal";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  		}
  		case "setLevel" {
  			#/json.htm?type=command&param=switchlight&idx=&switchcmd=Set%20Level&level=6
  			my $url;
  			if (($device_tab{$deviceId}->{"Action"}==2)or($device_tab{$deviceId}->{"Action"}==3)) {
  				if ($actionParam eq "100") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  				} else {
  					my $setLevel=ceil($actionParam*($device_tab{$deviceId}->{"MaxDimLevel"})/100);
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  				}
  			} elsif (($device_tab{$deviceId}->{"Action"}==5)) {
  				#Blinds inverted
  				if ($actionParam eq "100") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  				} else {
  					my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$setLevel&passcode=";
  				}
  			} elsif (($device_tab{$deviceId}->{"Action"}==6)) {
  				#Blinds -> On for Closed, Off for Open 
  				if ($actionParam eq "100") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=0&passcode=";
  				} else {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=0&passcode=";
  				}
  			} else {
  				if ($actionParam eq "1") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Off&level=$actionParam&passcode=";
  				} elsif ($actionParam eq "0") {
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=On&level=$actionParam&passcode=";
  
  				} else {
  					my $setLevel=ceil($actionParam*$device_tab{$deviceId}->{"MaxDimLevel"}/100);
  					$url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Set%20Level&level=$setLevel&passcode=";
  				}
  			}
  
  				debug($url);
  				my $browser = LWP::UserAgent->new;
  				my $response = $browser->get($url);
  				if ($response->is_success){ 
  					return { success => true};
  				} else {
  					status 'error';
  					return { success => false, errormsg => $response->status_line};
  				}
  		} 
  		case "stopShutter"{
  			#stopShutter (Venetian store)
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=Stop&level=0&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  			return { success => true};
  		}
  		case "pulseShutter" {
  				#pulseShutter	up/down
  				status 'error';
  				return { success => false, errormsg => "not implemented"};
  		}
  		case "setSetPoint" {
  			#DevThermostat
  			my $url=config->{domo_path}."/json.htm?type=setused&idx=$deviceId&used=true&setpoint=$actionParam";
  			debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  			return { success => true};
  		}
  		case 'launchScene' {
  			#launchScene
  			#/json.htm?type=command&param=switchscene&idx=&switchcmd=
  			my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$deviceId&switchcmd=On&passcode=";
  		debug($url);
  			my $browser = LWP::UserAgent->new;
  			my $response = $browser->get($url);
  			if ($response->is_success){ 
  				return { success => true};
  			} else {
  				status 'error';
  				return { success => false, errormsg => $response->status_line};
  			}
  			return { success => true};
  		}
  		case 'setColor' {
  			my $url=config->{domo_path}."/json.htm?type=command&param=setcolorbrightnessvalue&idx=$deviceId&passcode=";
  			debug($url);
  				my $browser = LWP::UserAgent->new;
  				my $response = $browser->get($url);
  				if ($response->is_success){ 
  					return { success => true};
  				} else {
  					status 'error';
  					return { success => false, errormsg => $response->status_line};
  				}
  		}
  		case 'setChoice' {
  			if ($deviceId=~/^S/) {
  				my ($sc)=$deviceId=~/S(\d+)/;
  				my $url=config->{domo_path}."/json.htm?type=command&param=switchscene&idx=$sc&switchcmd=$actionParam&passcode=";
  			debug($url);
  				my $browser = LWP::UserAgent->new;
  				my $response = $browser->get($url);
  				if ($response->is_success){ 
  					return { success => true};
  				} else {
  					status 'error';
  					return { success => false, errormsg => $response->status_line};
  				}
  			} elsif ($deviceId=~/^V/) {
  				my ($sc)=$deviceId=~/V(\d+)/;
  				if ($actionParam eq "play") {
  					$mpd->play;
  				}elsif ($actionParam eq "pause") {
  					$mpd->pause;
  				}elsif ($actionParam eq "stop") {
  					$mpd->stop;
  				}elsif ($actionParam eq "next") {
  					$mpd->next;
  				}elsif ($actionParam eq "prev") {
  					$mpd->next;
  				}elsif ($actionParam eq "volumeUP") {
  					$mpd->volume("+1");
  				}elsif ($actionParam eq "volumeDOWN") {
  					$mpd->volume("-1");
  				}
  			} else {
  				status 'error';
  				return { success => false, errormsg => "not implemented"};
  			}
  		}
  		case 'setMode' {
  				#setChoice string
  				status 'error';
  				return { success => false, errormsg => "not implemented"};
  			}
  		else {
  				status 'not_found';
  				return "What?";
  	   }
  	}
  };
  
  get '/devices' => sub {
  	my $feed={ "devices" => []};
  	my $t_unit="°C";
  	my $system_url = config->{domo_path}."/json.htm?type=devices&filter=all&used=true&order=Name";
  	my $decoded;
  	my @results;
  	my @unk_dev;         # list of unknown devices
  debug($system_url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			#Own device version
  			my $feeds={"id" => "S0", "name" => "MyDomoAtHome", "type" => "DevGenericSensor",  params =>[]};
  			my $ver="$VERSION";
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  			#Check for new version
  			my @and=&getLastVersion();
  			my $an1;my $an2;
  			if (($ver ne $and[0])&&($and[0] ne "err")) {
  				my $feeds={"id" => "S1", "name" => "New version found", "type" => "DevGenericSensor",  params =>[]};
  				$an1=$and[0];
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$an1", "unit"=> "", "graphable" => "false"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  			#
  			#Parse the devices tree
  			#
  			foreach my $f ( @results ) {
  				my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  				my $name=$f->{"Name"};
  				#$name=~s/\s/_/;
  				#$name=~s/\s/_/;
  				#$name=~s/\//_/; 
  				$name=~s/%/P/;
  				my $rbl;
  				 if ($f->{"SwitchType"}) {			
  					#print $f->{"idx"} . " " . $f->{"Name"} . " " . $f->{"Status"} . $f->{"LastUpdate"}."\n";
  					#$name.="_E";
  					my $bl=$f->{"Status"};
  					if ($bl eq "On") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Off") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=1;}
  					elsif ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=2;}
  					elsif ($bl eq "Panic") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					elsif ($bl eq "Normal") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=3;}
  					else { $rbl=$bl;}
  				}
  				switch($f->{"Type"}) {
  					case /Lighting/ {
  						$room_tab{"Switches"}=1;
  						switch($f->{"SwitchType"}) {
  							case ["On/Off","Lighting Limitless/Applamp","Contact","Dusk Sensor"] {
  								if ($f->{"SubType"} ne "RGBW") {
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  									push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRGBLight", "room" => "Switches", params =>[]};
  									if ($rbl=~/Set Level/) {
  										$rbl=1;
  										$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  										push (@{$feeds->{'params'}}, {"key" => "dimmable", "value" => "1" } );
  										push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  									}
  									push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  									push (@{$feed->{'devices'}}, $feeds );
  								}
  							}
  							case ["Push On Button","Push Off Button"] {
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  								if ($f->{"SwitchType"} eq "Push Off Button") {$rbl="0"};
  								if ($f->{"SwitchType"} eq "Push On Button") {$rbl="1"};
  								push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  								#push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"1"} );
  								#push (@{$feeds->{'params'}}, {"key" => "Level", "value" =>"$rbl"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Dimmer","Doorbell"] {
  								#DevDimmer	Dimmable light
  								#Status	Current status : 1 = On / 0 = Off	N/A
  								#Level	Current dim level (0-100)	%
  								#"idx" : "3", "Name" : "Alerte",  "Level" : 0,  "SwitchType" : "Dimmer",  "Status" : "Off","LastUpdate" : "2014-03-18 22:17:18"
  								if ($rbl=~/Set Level/) {$rbl=1;}
  								$device_tab{$f->{"idx"}}->{"MaxDimLevel"} = $f->{"MaxDimLevel"};
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDimmer", "room" => "Switches", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  								push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Blinds Inverted"] {
  								#DevShutter
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  								my $v;
  								if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  								my $bl=$f->{"Status"};my $rbl;
  								if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=5;}
  								elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=5;};
  								push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Unknown"] {
  								if ($f->{"SwitchTypeVal"} eq "16") {
  									#DevShutter
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  									my $v=$f->{"Level"};
  
  									push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {print STDERR "Unknown !";}
  							}
  							case "Blinds Percentage" {
  								#DevShutter
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  								my $v;
  								if ($f->{"Status"} eq "Open") {$v=100;} else {$v=$f->{"Level"}};
  								my $bl=$f->{"Status"};my $rbl;
  								if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  								elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  								push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  								push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Blinds","Venetian Blinds EU","Venetian Blinds US"] {
  								if ($f->{"SubType"} ne "RollerTrol, Hasta new") {
  									#DevShutter
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  									my $v;
  									if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  									my $bl=$f->{"Status"};my $rbl;
  									if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  									elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  									push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {
  									# "RollerTrol, Hasta new"
  									#DevShutter
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevShutter", "room" => "Switches", params =>[]};
  									my $v;
  									if ($f->{"Status"} eq "Open") {$v=100;} else {$v=0;};
  									my $bl=$f->{"Status"};my $rbl;
  									if ($bl eq "Open") { $rbl=1;$device_tab{$f->{"idx"}}->{"Action"}=6;}
  									elsif ($bl eq "Closed") { $rbl=0;$device_tab{$f->{"idx"}}->{"Action"}=6;};
  									push (@{$feeds->{'params'}}, {"key" => "stopable", "value" =>"1"} );
  									push (@{$feeds->{'params'}}, {"key" => "pulseable", "value" =>"0"} );
  									push (@{$feeds->{'params'}}, {"key" => "Level", "value" => "$v" } );
  									push (@{$feed->{'devices'}}, $feeds );
  								}
  							}
  							case "Motion Sensor" {
  								#DevMotion	Motion security sensor
  								#Status	CM180 status : 1 = On / 0 = Off	N/A
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevMotion", "room" => "Switches", params =>[]};
  								push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  								push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Door Lock" {
  								#DevLock	Door / window lock
  								#Status	CM180 status : 1 = On / 0 = Off	N/A
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDoor", "room" => "Switches", params =>[]};
  								push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  								push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  								push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							#DevDoor	Door / window security sensor
  							#DevFlood	Flood security sensor
  							#DevCO2Alert	CO2 Alert sensor
  						}
  					}
  					case "Security" {
  						#DevSmoke	Smoke security sensor
  						#Armable	Ability to arm the device : 1 = Yes / 0 = No	N/A
  						#Ackable	Ability to acknowledge alerts : 1 = Yes / 0 = No	N/A
  						#Armed	Current arming status : 1 = On / 0 = Off	N/A
  						#Tripped	Is the sensor tripped ? (0 = No - 1 = Tripped)	N/A				
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSmoke", "room" => "Switches", params =>[]};
  						push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  						push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  						push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  						#"GET http://192.168.0.24:8080/json.htm?type=command&param=resetsecuritystatus&idx=202&switchcmd=Normal"
  						push (@{$feed->{'devices'}}, $feeds );				
  					}
  
  					case ["P1 Smart Meter","YouLess Meter"] {
  						$room_tab{"Utility"}=1;
  						switch($f->{"SubType"}) {
  							case ["Energy","YouLess counter"] {
  								#DevElectricity Electricity consumption sensor
  								#Watts  Current consumption     Watt
  								#ConsoTotal     Current total consumption       kWh
  								#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								my $usage;
  								if ($f->{"Usage"}) {
  									($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  									push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  								} elsif ($f->{"Counter"}) {
  									($usage)= ($f->{"Counter"} =~ /(\d+) Watt/);
  									push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W", "graphable" => "true"} );
  								}
  								my ($total)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								$total=ceil($total);
  								push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case"Gas" {
  								# (Dutch)P1 Gas Meter
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  								my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "m3"} );
  								push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "m3"} );
  								push (@{$feed->{'devices'}}, $feeds );							
  								# Generic Sensor showing today's value
  								my ($usage_today)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								$feeds={"id" => $f->{"idx"}."_today", "name" => $name."_today", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage_today", "unit"=> "m3", "graphable" => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  						}
  					}
  					case "Energy" {
  						$room_tab{"Utility"}=1;
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						#if ($f->{"Usage"}) {
  							my $usage;
  							($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  							if (!$usage) {$usage="0";}
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "W"} );#}
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$total", "unit" => "kWh", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Usage" {
  						$room_tab{"Utility"}=1;
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#"Type" : "Usage", "SubType" : "Electric", "Data" : "122.3 Watt"
  						my ($total)= ($f->{"Data"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  						$total=ceil($total);
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  						push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$total", "unit" => "W"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Current/Energy" {
  						$room_tab{"Utility"}=1;
  						#DevElectricity Electricity consumption sensor
  						#Watts  Current consumption     Watt
  						#ConsoTotal     Current total consumption       kWh
  						#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  						my ($L1,$L2,$L3,$tot)= split(/,/,$f->{"Data"});
  						my ($l1)= ($L1 =~ /(\d+) Watt/);
  						my ($l2)= ($L2 =~ /(\d+) Watt/);
  						my ($l3)= ($L3 =~ /(\d+) Watt/);
  						if ($l1) {	
  							my $feeds={"id" => $f->{"idx"}."_L1", "name" => $name." L1", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l1", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l2) {	
  							my $feeds={"id" => $f->{"idx"}."_L2", "name" => $name." L2", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l2", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  						if ($l3) {	
  							my $feeds={"id" => $f->{"idx"}."_L3", "name" => $name." L3", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  							push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$l3", "unit" => "W"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						}
  					}
  					case "Temp + Humidity"  {
  						$room_tab{"Temp"}=1;
  						my $feeds;
  						$feeds={params =>[],"room" => "Temp","type" => "DevTempHygro","name" => $name, "id" => $f->{"idx"}};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "temp", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  						my $vh=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "hygro", "value" => "$vh", "unit" => "%", "graphable" => "true" });
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Temp + Humidity + Baro"  {
  						$room_tab{"Temp"}=1;
  						my $feeds;
  						$feeds={params =>[],"room" => "Temp","type" => "DevTempHygro","name" => $name, "id" => $f->{"idx"}};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "temp", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  						my $vh=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "hygro", "value" => "$vh", "unit" => "%", "graphable" => "true" });
  						push (@{$feed->{'devices'}}, $feeds );
  						if ($f->{"Type"} =~ "Baro") {
  							#DevPressure    Pressure sensor
  							#Value  Current pressure        mbar
  							#"Barometer" : 1022, "Type" : "Temp + Humidity + Baro"
  							my $idx=$f->{"idx"};
  							$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  							if ($f->{"Type"} eq "Temp + Humidity + Baro") {$idx=$idx."_1"};
  							my $feeds={"id" => $idx, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  							my $v=$f->{"Barometer"};
  							push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar"} );
  								push (@{$feed->{'devices'}}, $feeds );
  						}
  					}
  					case "Temp" {
  						#DevTemperature Temperature sensor
  						#Value  Current temperature     *C
  						#"Temp" : 21.50,  "Type" : "Temp + Humidity" / Type" : "Temp",
  						$device_tab{$f->{"idx"}}->{"graph"} = 'te';
  						my $feeds;
  						$feeds={params =>[],"room" => "Temp","type" => "DevTemperature","name" => $name, "id" => $f->{"idx"}};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => $t_unit, "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Humidity" {
  						#DevHygrometry  Hygro sensor
  						#Value  Current hygro value     %
  						# "Humidity" : 52  "Type" : "Temp + Humidity" / Type" : "Humidity",
  						$device_tab{$f->{"idx"}}->{"graph"} = 'hu';
  
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevHygrometry", "room" => "Temp", params =>[]};
  						my $v=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true" });
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Rain"  {
  						$room_tab{"Temp"}=1;
  						#DevRain        Rain sensor
  						#Value  Current instant rain value      mm/h
  						#Accumulation   Total rain accumulation mm
  						#"Rain" : "0.0", "RainRate" : "0.0", "Type" : "Rain"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'mm';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRain", "room" => "Temp", params =>[]};
  						my $v0=$f->{"RainRate"};
  						my $v1=$f->{"Rain"};
  						push (@{$feeds->{'params'}}, {"key" => "Accumulation", "value" => "$v1", "unit" => "mm", "graphable" => "true"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v0", "unit" => "mm/h"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "UV"  {
  						$room_tab{"Temp"}=1;
  						#DevUV  UV sensor
  						#Value  Current UV index        index
  						# "Type" : "UV","UVI" : "6.0"
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevUV", "room" => "Temp", params =>[]};
  						my $v=$f->{"UVI"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Lux"  {
  						$room_tab{"Utility"}=1;
  						#DevLux  Lux sensor
  						#Value  Current Lux value        index
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevLuminosity", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) Lux/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'uvi';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "graphable" => "true"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Air Quality"  {
  						$room_tab{"Utility"}=1;
  						#DevCO2  CO2 sensor
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevCO2", "room" => "Temp", params =>[]};
  						my ($v)=($f->{"Data"}=~/(\d+) ppm/);
  						$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "ppm", "graphable" => "true"});
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "Wind"  {
  						$room_tab{"Temp"}=1;
  						#DevWind wind
  						$device_tab{$f->{"idx"}}->{"graph"} = 'sp';
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevWind", "room" => "Temp", params =>[]};
  						my ($dir)=($f->{"Direction"}=~/(\d+)/);
  						my ($speed)=($f->{"Speed"}=~/(\d+)/);
  						push (@{$feeds->{'params'}}, {"key" => "Speed", "value" => "$speed", "unit" => "km/h", "graphable" => "true"});
  						push (@{$feeds->{'params'}}, {"key" => "Direction", "value" => "$dir", "unit" => "°"});
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  					case "RFXMeter"  {
  						$room_tab{"Utility"}=1;
  						switch($f->{"SwitchTypeVal"}) {
  							case "1" {
  								#Gas
  								my ($usage)= ($f->{"CounterToday"} =~ /(\d+) m3/);
  								my ($total)= ($f->{"Counter"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								$total=ceil($total);
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$usage, "unit" => "m3"} );
  								 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>$total, "unit" => "m3"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "2" {
  								#Water
  								my ($usage)= ($f->{"CounterToday"} =~ /([0-9]+(?:\.[0-9]+)?)/);
  								my ($total)= ($f->{"Counter"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								my $totalm3=ceil($total);
  								my $usagem3=ceil($usage/1000);
  								my $feeds={"id" => $f->{"idx"}, "name" => "$name", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usagem3", "unit" => "m3", "graphable" => "true"} );
  								 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>"$totalm3", "unit" => "m3"} );
  								push (@{$feed->{'devices'}}, $feeds );
  								#Water by liter
  								my $usage2=$usage; #move to liters
  								$feeds={"id" => $f->{"idx"}."_l", "name" => $name."_l", "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$usage2", "unit"=> "L"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "3" {
  								if ($f->{"SubType"} eq "RFXMeter counter") {
  									#Counter
  									$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  									my ($v)=($f->{"Counter"}=~/^([^\s]+)/);
  									push (@{$feeds->{'params'}}, {"key" => "Watts", "value" => "$v"} );
  									push (@{$feed->{'devices'}}, $feeds );
  								} else {
  									push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  								}
  							}
  							else {
  								push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  							}
  						}
  					}
  					case "General"  {
  						$room_tab{"Utility"}=1;
  						switch($f->{"SubType"}) {
  							case "Percentage" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%", "graphable" => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Voltage" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "V"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "kWh" {
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  								my $usage;
  								($usage)= ($f->{"Usage"} =~ /^(\d+\.\d+) Watt/);
  								push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>"$usage", "unit" => "kWh", "graphable" => "false"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Pressure" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar", "graphable" => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							} 
  							case "Visibility" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "km"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							} 
  							case "Solar Radiation" {
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Temp", params =>[]};
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "Watt/m2"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							case ["Text","Alert","Unknown"] {	   
  									my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevGenericSensor", "room" => "Utility", params =>[]};
  									my $v= $f->{"Data"};
  									push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => ""} );
  									push (@{$feed->{'devices'}}, $feeds );
  							}
  							case "Sound Level" {	   
  								$device_tab{$f->{"idx"}}->{"graph"} = 'v';
  								my ($v)= ($f->{"Data"} =~ /^([0-9]+) dB/);
  								my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevNoise", "room" => "Utility", params =>[]};
  								push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "dB", graphable => "true"} );
  								push (@{$feed->{'devices'}}, $feeds );
  							}
  							else { 
  								push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  							}
  						}
  					}
  					case "Thermostat" {
  						$room_tab{"Temp"}=1;
  						if ($f->{"SubType"} eq "SetPoint") {
  							my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevThermostat", "room" => "Temp", params =>[]};
  							my ($v)= ($f->{"SetPoint"} =~ /^([0-9]+(?:\.[0-9]+)?)/);
  							push (@{$feeds->{'params'}}, {"key" => "cursetpoint", "value" => "$v"});
  							push (@{$feeds->{'params'}}, {"key" => "curtemp", "value" => "$v", "unit"=>$t_unit} );
  							push (@{$feeds->{'params'}}, {"key" => "step", "value" => "0.5"} );
  							push (@{$feeds->{'params'}}, {"key" => "curmode", "value" => "default"} );
  							push (@{$feeds->{'params'}}, {"key" => "availablemodes", "value" => "default"} );
  							push (@{$feed->{'devices'}}, $feeds );
  						} else {
  							push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}
  					} 
  					else {
  						#catchall
  						if ($f->{"idx"}>5) {push @unk_dev,$f->{"idx"}."-".$f->{"Name"}."-".$f->{"Type"}."-".$f->{"SubType"}."-".$f->{"SwitchTypeVal"};
  						}					
  					}
  				}
  			}
  
  			#Unknown device list
  			my $ind_unk=2;
  			foreach my $devt ( @unk_dev)  {
  				my $feeds={"id" => "S".$ind_unk++, "name" => "$devt", "type" => "DevGenericSensor", "room" => "", params =>[]};
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"unk", "unit"=> "", "graphable" => "false"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  		} else {
  			my $feeds={"id" => "S00", "name" => "Unable to decode URL", "type" => "DevGenericSensor",  params =>[]};
  			my $ver=config->{domo_path};
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  			$feeds={"id" => "S01", "name" => "Please add this gateway in Setup/settings/Local Networks", "type" => "DevGenericSensor",  params =>[]};
  			push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"", "unit"=> "", "graphable" => "false"} );
  			push (@{$feed->{'devices'}}, $feeds );
  		}
  	} else {
  		my $feeds={"id" => "S00", "name" => "Unable to connect to Domoticz", "type" => "DevGenericSensor",  params =>[]};
  		my $ver=config->{domo_path};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"$ver", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  		$feeds={"id" => "S01", "name" => "Please add this gateway in Setup/settings/Local Networks", "type" => "DevGenericSensor",  params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>"", "unit"=> "", "graphable" => "false"} );
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#MPD
  	if ($mpd_host ne '') {
  		$mpd=Audio::MPD->new ( host => $mpd_host);
  		$room_tab{"Music"}=1;
  	}
  	#Status
  	if ($mpd_host) {
  		my $status = $mpd->status;
  		my $song = $mpd->current;
  		my $feeds={"id" => "V2", "name" => $song->artist." - ".$song->album, "type" => "DevMultiSwitch", "room" => "Volumio", params =>[]};
  		push (@{$feeds->{'params'}}, {"key" => "Value", "value" =>$status->state, "unit"=> "", "graphable" => "false"} );
  		push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "play,stop,pause,next,prev,volumeUP,volumeDOWN"});
  		push (@{$feed->{'devices'}}, $feeds );
  	}
  
  	#Get Scenes
  	$system_url=config->{domo_path}."/json.htm?type=scenes";
  	$json = $ua->get( $system_url );
  	#warn "Could not get $system_url!" unless defined $json;
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			$room_tab{"Scene"}=1;
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  	#	debug($dt->strftime("%Y-%m-%d %H:%M:%S"));
  					my $name=$f->{"Name"};
  					$name=~s/%/P/;
  					#DevScene       Scene (launchable)
  					#LastRun        Date of last run        N/A
  					#"idx" : "3", "Name" : "Alerte", "Type" : "Scenes", "LastUpdate" : "2014-03-18 22:17:18"
  					if ($f->{"Type"} eq "Group") {
  						my $feeds={"id" => "S".$f->{"idx"}, "name" => $name, "type" => "DevMultiSwitch", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => $f->{"Status"}} );
  						push (@{$feeds->{'params'}}, {"key" => "Choices", "value" => "Mixed,On,Off"} );
  						push (@{$feed->{'devices'}}, $feeds );
  
  					} else {
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevScene", "room" => "Scenes", params =>[]};
  						my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  						push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  			}
  		}
  	}
  	#Get Camera
  	$system_url=config->{domo_path}."/json.htm?type=cameras";
  debug($system_url);
  	$json = $ua->get( $system_url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  					my $name=$f->{"Name"};
  					$name=~s/\s/_/;
  					$name=~s/\s/_/;
  					$name=~s/\//_/;
  					$name=~s/%/P/;
  					my $feeds={"id" => $f->{"idx"}."_cam", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  					my $v=$f->{"ImageURL"};my $v2=config->{external_url_camera};my $v3=$f->{"VideoURL"};
  					if ($v =~ /^http/) {
  						push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  					} else {
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  						} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"ImageURL"};
  							push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  	
  						}
  					}
  					if ($v2) {push (@{$feeds->{'params'}}, {"key" => "remotejpegurl", "value" => "$v2"} );}
  					push (@{$feed->{'devices'}}, $feeds );
  					# Now if VideoURL
  					if ($v3) {
  						my $feeds2={"id" => $f->{"idx"}."_video", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  						if ($f->{"Username"}) {
  							$v="http://".$f->{"Username"}.":".$f->{"Password"}."@".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							} else {
  							$v="http://".$f->{"Address"}.":".$f->{"Port"}."/".$f->{"VideoURL"};
  							push (@{$feeds2->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  							}
  						push (@{$feed->{'devices'}}, $feeds2 );
  						}
  			}
  		}
  	}
  	#DevGenericSensor      Generic sensor (any value)
  	#Value  Current value   N/A
  
  	return to_json($feed, { utf8 => 0} );
  	return { success => true};
  };
  
  sub getDeviceType($) {
  	my ($deviceId)=@_;
  	my $url=config->{domo_path}."/json.htm?type=devices&rid=$deviceId";
  	my $decoded;
  	my @results;
  debug($url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $url );
  	if ($json->is_success) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(1)->decode( $json->decoded_content );
  		if ($decoded->{'result'}) {
  			@results = @{ $decoded->{'result'} };
  			foreach my $f ( @results ) {
  				if ($f->{SubType} eq "RFXMeter counter") {
  					return("counter");
  				} else {
  					return($f->{Type});
  				}
  			}
  		}
  	}
  }
  sub getLastVersion() {
  	my $dt = DateTime->now;
  	if ($last_version_dt < $dt->add( hours => 4 )) {
  		my @res;
  		push @res,$last_version;
  		push @res,"";
  		return(@res);
  	} else {
  		my $url="https://api.github.com/repos/empierre/MyDomoAtHome/releases/latest";
  		my $decoded;
  		my @results;
  	debug($url);
  		my $ua = LWP::UserAgent->new();
  		$ua->agent("MyDomoREST/$VERSION");
  		my $json = $ua->get( $url );
  		if ($json->is_success) {
  			# Decode the entire JSON
  			$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  			if ($decoded) {
  				my @res;
  				push @res,$decoded->{tag_name};
  				push @res,$decoded->{body};
  				$last_version_dt=DateTime->now;
  				$last_version=$decoded->{tag_name};
  				return(@res);
  			}
  		} else {return "err";}
  	}
  }
  1;
DOMO2

$fatpacked{"HTTP/Message/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use HTTP::Status qw(status_message);
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
          $req->content_length(length $content)
              unless defined $req->content_length;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path || '/'),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query || '/',                     # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      if (!defined($env->{HTTP_HOST}) && $req->uri->can('host')) {
          $env->{HTTP_HOST} = $req->uri->host;
          $env->{HTTP_HOST} .= ':' . $req->uri->port
              if $req->uri->port ne $req->uri->default_port;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      require HTTP::Response;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      } elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      } else {
          Carp::croak("Bad response: ", defined $psgi_res ? $psgi_res : 'undef');
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->message(status_message($status));
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content = '';
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods to convert an L<HTTP::Request>
  object to a PSGI env hash and convert a PSGI response arrayref to
  a L<HTTP::Response> object.
  
  If you want the other way around, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts a L<HTTP::Request> object into a PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates a L<HTTP::Response> object from a PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi>, but is a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Stream::Buffered;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          ssl                => $args{ssl},
          ipv6               => $args{ipv6},
          ssl_key_file       => $args{ssl_key_file},
          ssl_cert_file      => $args{ssl_cert_file},
      }, $class;
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub prepare_socket_class {
      my($self, $args) = @_;
  
      if ($self->{ssl} && $self->{ipv6}) {
          Carp::croak("SSL and IPv6 are not supported at the same time (yet). Choose one.");
      }
  
      if ($self->{ssl}) {
          eval { require IO::Socket::SSL; 1 }
              or Carp::croak("SSL suport requires IO::Socket::SSL");
          $args->{SSL_key_file}  = $self->{ssl_key_file};
          $args->{SSL_cert_file} = $self->{ssl_cert_file};
          return "IO::Socket::SSL";
      } elsif ($self->{ipv6}) {
          eval { require IO::Socket::IP; 1 }
              or Carp::croak("IPv6 support requires IO::Socket::IP");
          $self->{host}      ||= '::';
          $args->{LocalAddr} ||= '::';
          return "IO::Socket::IP";
      }
  
      return "IO::Socket::INET";
  }
  
  sub setup_listener {
      my $self = shift;
  
      my %args = (
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      );
  
      my $class = $self->prepare_socket_class(\%args);
      $self->{listen_sock} ||= $class->new(%args)
          or die "failed to listen to port $self->{port}: $!";
  
      $self->{server_ready}->({ %$self, proto => $self->{ssl} ? 'https' : 'http' });
  }
  
  sub accept_loop {
      my($self, $app) = @_;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (1) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  REMOTE_PORT => $conn->peerport || 0,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => $self->{ssl} ? 'https' : 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.harakiri'    => Plack::Util::TRUE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
              last if $env->{'psgix.harakiri.commit'};
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Stream::Buffered->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout})
                              or return;
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      return 0 unless defined $buf;
      _encode($buf);
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  # syswrite() will crash when given wide characters
  sub _encode {
      if ($_[0] =~ /[^\x00-\xff]/) {
          Carp::carp("Wide character outside byte range in response. Encoding data as UTF-8");
          utf8::encode($_[0]);
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testing, but might
  not be suitable for a production use.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported, and it also does not support
  HTTP/0.9.
  
  See L<Starman> or uWSGI server if you want HTTP/1.1 and other features
  ready for a production use.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 HARAKIRI SUPPORT
  
  This web server supports `psgix.harakiri` extension defined in the
  L<PSGI::Extensions>.
  
  This application is a non-forking single process web server
  (i.e. `psgi.multiprocess` is false), and if your application commits
  harakiri, the entire web server stops too. In case this behavior is
  not what you want, be sure to check `psgi.multiprocess` as well to
  enable harakiri only in the preforking servers such as L<Starman>.
  
  On the other hand, this behavior might be handy if you want to embed
  this module in your application and serve HTTP requests for only short
  period of time, then go back to your main program.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"MySensors.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MYSENSORS';
  package Domo;
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  # Author: epierre
  use Dancer ':syntax';
  use DBI;
  use File::Spec;
  use File::Slurp;
  use LWP::UserAgent;
  use Crypt::SSLeay;
  use utf8;
  use Time::Piece;
  use Device::SerialPort;
  use IO::Handle;
  use feature     qw< unicode_strings >;
  #use JSON;
  
  our $VERSION = '0.2';
  set warnings => 0;
  set 'database'     => File::Spec->catfile(File::Spec->tmpdir(), 'mysensors.db');
  
  
  set serializer => 'JSON'; 
  prefix undef;
  # USB port opening
  my $ob = &connect_usb(config->{usb_port});
  my $domo_ip = config->{domo_ip};
  my $domo_port = config->{domo_port};
  my %sensor_tab;
  
  get '/' => sub {
      template 'index';
  };
  
  get '/rooms' => sub {
         #Room list
    return {"rooms" => [ 
  		{ "id"=> "noroom", "name"=> "noroom" },
  		{ "id"=> "Switches", "name"=> "Switches" },
  		{ "id"=> "Scenes", "name"=> "Scenes" },
  		{ "id"=> "Temp", "name"=> "Weather" },
  		{ "id"=> "Utility", "name"=> "Utility" },
  			]};
  };
  
  get '/system' => sub {
   return {"id"=> "MyDomoAtHome","apiversion"=> 1};
  };
  
  
  get '/devices/:deviceId/action/:actionName/:actionParam?' => sub {
  my $deviceId = params->{deviceId};
  my $actionName = params->{actionName};
  my $actionParam = params->{actionParam}||"";
  };
  
  get '/message/:radioId/:childId/:messageType/:subType/:payload?' => sub {
  	my $radioId = params->{radioId};
  	my $childId = params->{childId};
  	my $messageType = params->{messageType};
  	my $subType = params->{subType};
  	my $payload = params->{payload}||"0";
  
  	my $dt = DateTime->now;
  	my $date=join ' ', $dt->ymd, $dt->hms;
  	 
  	
  	if ($messageType==4) {
  		#I_RELAY_NODE 		1 255 4 7 0 
  		#I_SKETCH_NAME 		1 255 4 14 Humidity
  		#I_SKETCH_VERSION 	1 255 4 15 1.0
  
  		if ($subType==5) {
  		#Gives a new node its ID
  			my $db = connect_db();
  			my $sql = "insert into device (I_BATTERY_LEVEL,I_RELAY_NODE,I_UNIT) values (100,255,'M')";
  			my $sth = $db->prepare($sql) or die $db->errstr;
  			$sth->execute or die $sth->errstr;
  			#get the id
  			$sql = 'SELECT last_insert_rowid() FROM device';
  			$sth = $db->prepare($sql) or die $db->errstr;
  			$sth->execute or die $sth->errstr;
  			my $row;my $id;while($row = $sth->fetchrow_hashref()) { $id=$row->{id};}			
             	my $msg = "$radioId;$childId;4;5;$id\n";
              my $co = $ob->write($msg);
              if (!$co) {
  					status 'error';
  					return { success => false, errormsg => "USB write failed"};					
  			}
              $ob->write_drain;
  			return { success => true};					
  		}
  		if ($subType==9) {
  		#I_PING
               my $msg = "$radioId;$childId;4;10;\n";
               my $co = $ob->write($msg);
               if (!$co) {
  					status 'error';
  					return { success => false, errormsg => "USB write failed"};					
  			 }
               $ob->write_drain;
  			 return { success => true};					
  		}
  		if ($subType==13) {
  		#Answer we are Metric
  		#I_UNIT 			1 255 4 13 0
               my $msg = "$radioId;$childId;4;13;M\n";
               my $co = $ob->write($msg);
               if (!$co) {
  					status 'error';
  					return { success => false, errormsg => "USB write failed"};					
  			 }
               $ob->write_drain;
  			 return { success => true};					
  		}
      } elsif ($messageType==1) {
  		$sensor_tab{$radioId}->{$subType}=$payload;
  		&update_sensor($radioId,$subType,$payload);
  		if($subType==0) {
  		# Read the Temp value
  	  		 my $hum=$sensor_tab{$radioId}->{1}||0;
  			 next if ($hum<=0);		
  			 `curl -s "http://$domo_ip:$domo_port/json.htm?type=command&param=udevice&idx=164&svalue=$payload;$hum;2" &`;
  			 return { success => true};					
  		}
  		if ($subType==1) {
  			# Read the Humidity value
  			my $temp=$sensor_tab{$radioId}->{0}||0;
  			next if ($temp<=0);
  			`curl -s "http://$domo_ip:$domo_port/json.htm?type=command&param=udevice&idx=164&svalue=$temp;$payload;2" &`;
  			return { success => true};					
  		} 
  	} elsif ($messageType==3) {
  	#Variable Acknowledgments	
  	} elsif ($messageType==0) {
  	#Presentation	
  	#1 255 0 17 1.3b3 (67f4ca1)
  	#S_ARDUINO_NODE		17	Arduino node device
  	#S_ARDUINO_RELAY	18	Arduino relaying node device
  		if ($subType==17) {
  			my $db = connect_db();
  			my $sql = 'insert into sensor (device_id, subtype,version) values (?, ?, ?)';
  			my $sth = $db->prepare($sql) or die $db->errstr;
  			$sth->execute($radioId, ) or die $sth->errstr;
  		}	
  	};
  
  if ($actionName eq 'setStatus') {
          #setStatus	0/1
  	my $action;
  	if ($actionParam eq 0) {
  		$action="Off";
  	} else {
  		$action="On";
  	}
  	my $url=config->{domo_path}."/json.htm?type=command&param=switchlight&idx=$deviceId&switchcmd=$action&level=0&passcode=";
  	my $browser = LWP::UserAgent->new;
  	my $response = $browser->get($url);
  	if ($response->is_success){ 
  		return { success => true};
  	} else {
  		status 'error';
  		return { success => false, errormsg => $response->status_line};
  	}
  } elsif ($actionName eq 'setArmed') {
  	#setArmed	0/1
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'setAck') {
  	#setAck	
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'setLevel') {
  	#setLevel	0-100
  	#/json.htm?type=command&param=switchlight&idx=&switchcmd=Set%20Level&level=6
  	return { success => true};
  } elsif ($actionName eq 'stopShutter') {
  	#stopShutter
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'pulseShutter') {
  	#pulseShutter	up/down
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
  } elsif ($actionName eq 'launchScene') {
  	#launchScene
  	#/json.htm?type=command&param=switchscene&idx=&switchcmd=
  	return { success => true};
  } elsif ($actionName eq 'setChoice') {
  	#setChoice string
  	status 'error';
  	return { success => false, errormsg => "not implemented"};
      } else {
          status 'not_found';
          return "What?";
     }
  };
  
  get '/devices' => sub {
  	my $feed={ "devices" => []};
  	my $system_url = config->{domo_path}."/json.htm?type=devices&filter=all&used=true&order=Name";
  debug($system_url);
  	my $ua = LWP::UserAgent->new();
  	$ua->agent("MyDomoREST/$VERSION");
  	my $json = $ua->get( $system_url );
  	warn "Could not get $system_url!" unless defined $json;
  	# Decode the entire JSON
  	my $decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  	my @results = @{ $decoded->{'result'} };
  	foreach my $f ( @results ) {
  			my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  			my $name=$f->{"Name"};
  			$name=~s/\s/_/;
  			$name=~s/\s/_/;
  			$name=~s/\//_/;
  			$name=~s/%/P/;
  		 if ($f->{"SwitchType"}) {			
  			#print $f->{"idx"} . " " . $f->{"Name"} . " " . $f->{"Status"} . $f->{"LastUpdate"}."\n";
  			$name.="_E";
  			my $bl=$f->{"Status"};my $rbl;
  			if ($bl eq "On") { $rbl=1;}
  			elsif ($bl eq "Off") { $rbl=0;}
  			elsif ($bl eq "Opened") { $rbl=1;}
  			elsif ($bl eq "Closed") { $rbl=0;}
  			else { $rbl=$bl;}
  			if ($f->{"SwitchType"} eq "On/Off") {
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSwitch", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"SwitchType"} eq "Dimmer") {
  				#DevDimmer	Dimmable light
  				#Status	Current status : 1 = On / 0 = Off	N/A
  				#Level	Current dim level (0-100)	%
  				#"idx" : "3", "Name" : "Alerte",  "Level" : 0,  "SwitchType" : "Dimmer",  "Status" : "Off","LastUpdate" : "2014-03-18 22:17:18"
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDimmer", "room" => "Switches", params =>[]};
  
  				push (@{$feeds->{'params'}}, {"key" => "Status", "value" =>"$rbl"} );
  				push (@{$feeds->{'params'}}, {"key" => "Level", "value" => $f->{"Level"} } );
  
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"SwitchType"} eq "Motion Sensor") {
  				#DevMotion	Motion security sensor
  				#Status	Current status : 1 = On / 0 = Off	N/A
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevMotion", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  				push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"SwitchType"} eq "Door Lock") {
  				#DevLock	Door / window lock
  				#Status	Current status : 1 = On / 0 = Off	N/A
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevDoor", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  				push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  				push (@{$feed->{'devices'}}, $feeds );
  			}elsif ($f->{"SwitchType"} eq "Smoke Detector") {
  				#DevSmoke	Smoke security sensor
  				#Armable	Ability to arm the device : 1 = Yes / 0 = No	N/A
  				#Ackable	Ability to acknowledge alerts : 1 = Yes / 0 = No	N/A
  				#Armed	Current arming status : 1 = On / 0 = Off	N/A
  				#Tripped	Is the sensor tripped ? (0 = No - 1 = Tripped)	N/A				
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevSmoke", "room" => "Switches", params =>[]};
  				push (@{$feeds->{'params'}}, { "key" => "Armable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Ackable", "value" => "0" } );
  				push (@{$feeds->{'params'}}, { "key" => "Armed", "value" => "1" } );
  				push (@{$feeds->{'params'}}, { "key" => "Tripped", "value" => $rbl });
  				push (@{$feed->{'devices'}}, $feeds );				
  			}
  			#DevDoor	Door / window security sensor
  			#DevFlood	Flood security sensor
  			#DevCO2Alert	CO2 Alert sensor	
  		} else {
  			if ($f->{"Type"} eq "Energy") {
  				#DevElectricity Electricity consumption sensor
  				#Watts  Current consumption     Watt
  				#ConsoTotal     Current total consumption       kWh
  				#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  				my ($usage)= ($f->{"Usage"} =~ /(\d+) Watt/);
  				my ($total)= ($f->{"Data"} =~ /(\d+).\d+ kWh/);
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevElectricity", "room" => "Utility", params =>[]};
  				push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$usage, "unit" => "W"} );
  				 push (@{$feeds->{'params'}}, {"key" => "ConsoTotal", "value" =>$total, "unit" => "kWh"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"Type"} eq "Current/Energy") {
  				#DevElectricity Electricity consumption sensor
  				#Watts  Current consumption     Watt
  				#ConsoTotal     Current total consumption       kWh
  				#"Type" : "Energy", "SubType" : "CM180", "Usage" : "408 Watt", "Data" : "187.054 kWh"
  				my ($L1,$L2,$L3,$tot)= split(/,/,$f->{"Data"});
  				my ($l1)= ($L1 =~ /(\d+) Watt/);
  				my ($l2)= ($L2 =~ /(\d+) Watt/);
  				my ($l3)= ($L3 =~ /(\d+) Watt/);
  				if ($l1) {	
  					my $feeds={"id" => $f->{"idx"}."_L1", "name" => $name." L1", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  					push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$l1, "unit" => "W"} );
  					push (@{$feed->{'devices'}}, $feeds );
  				}
  				if ($l2) {	
  					my $feeds={"id" => $f->{"idx"}."_L2", "name" => $name." L2", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  					push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$l2, "unit" => "W"} );
  					push (@{$feed->{'devices'}}, $feeds );
  				}
  				if ($l3) {	
  					my $feeds={"id" => $f->{"idx"}."_L3", "name" => $name." L3", "type" => "DevElectricity", "room" => "Utility", params =>[]};
  					push (@{$feeds->{'params'}}, {"key" => "Watts", "value" =>$l3, "unit" => "W"} );
  					push (@{$feed->{'devices'}}, $feeds );
  				}
  			}  elsif (($f->{"Type"} =~ "Temp")||($f->{"Type"} =~ "Humidity"))  {
  				my @type=split(/ \+ /,$f->{"Type"});
  				my $cnt;
  				foreach my $curs (@type) {
  					$cnt++;
  					if ($curs eq "Temp") {
  						#DevTemperature Temperature sensor
  						#Value  Current temperature     °C
  						#"Temp" : 21.50,  "Type" : "Temp + Humidity" / Type" : "Temp",
  
  						my $feeds={params =>[],"room" => "Temp","type" => "DevTemperature","name" => $name, "id" => $f->{"idx"}."_".$cnt};
  						my $v=$f->{"Temp"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "°C"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($curs eq "Humidity") {
  						#DevHygrometry  Hygro sensor
  						#Value  Current hygro value     %
  						# "Humidity" : 52  "Type" : "Temp + Humidity" / Type" : "Humidity",
  
  						my $feeds={"id" => $f->{"idx"}."_".$cnt, "name" => $name, "type" => "DevHygrometry", "room" => "Temp", params =>[]};
  						my $v=$f->{"Humidity"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "%"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					} elsif ($curs eq "Baro") {
  						#DevPressure    Pressure sensor
  						#Value  Current pressure        mbar
  						#"Barometer" : 1022, "Type" : "Temp + Humidity + Baro"
  						my $feeds={"id" => $f->{"idx"}."_".$cnt, "name" => $name, "type" => "DevPressure", "room" => "Temp", params =>[]};
  						my $v=$f->{"Barometer"};
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v", "unit" => "mbar"} );
  						push (@{$feed->{'devices'}}, $feeds );
  					}
  				}
  			}  elsif ($f->{"Type"} eq "Rain")  {
  				#DevRain        Rain sensor
  				#Value  Current instant rain value      mm/h
  				#Accumulation   Total rain accumulation mm
  				#"Rain" : "0.0", "RainRate" : "0.0", "Type" : "Rain"
  						my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevRain", "room" => "Temp", params =>[]};
  						my $v0=$f->{"RainRate"};
  						my $v1=$f->{"Rain"};
  						push (@{$feeds->{'params'}}, {"key" => "Accumulation", "value" => "$v1", "unit" => "mm"} );
  						push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v0", "unit" => "mm/h"} );
  						push (@{$feed->{'devices'}}, $feeds );
  			} elsif ($f->{"Type"} eq "UV")  {
  				#DevUV  UV sensor
  				#Value  Current UV index        index
  				# "Type" : "UV","UVI" : "6.0"
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevUV", "room" => "Temp", params =>[]};
  				my $v=$f->{"UVI"};
  				push (@{$feeds->{'params'}}, {"key" => "Value", "value" => "$v"} );
  				push (@{$feed->{'devices'}}, $feeds );
  			}
  
  		}
  
  
  	}; 
  	#Get Scenes
  	$system_url=config->{domo_path}."/json.htm?type=scenes";
  	$json = $ua->get( $system_url );
  	warn "Could not get $system_url!" unless defined $json;
  	if ($json) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  		@results = @{ $decoded->{'result'} };
  		foreach my $f ( @results ) {
  				my $dt = Time::Piece->strptime($f->{"LastUpdate"},"%Y-%m-%d %H:%M:%S");
  #	debug($dt->strftime("%Y-%m-%d %H:%M:%S"));
  				my $name=$f->{"Name"};
  				$name=~s/\s/_/;
  				$name=~s/\s/_/;
  				$name=~s/\//_/;
  				$name=~s/%/P/;
  				#DevScene       Scene (launchable)
  				#LastRun        Date of last run        N/A
  				#"idx" : "3", "Name" : "Alerte", "Type" : "Scenes", "LastUpdate" : "2014-03-18 22:17:18"
  				my $feeds={"id" => $f->{"idx"}, "name" => $name, "type" => "DevScene", "room" => "Scenes", params =>[]};
  				my $v=$dt->strftime("%Y-%m-%d %H:%M:%S");
  				push (@{$feeds->{'params'}}, {"key" => "LastRun", "value" => "$v"} );
  				push (@{$feed->{'devices'}}, $feeds );
  		}
  	}
  	#Get Camera
  	$system_url=config->{domo_path}."/json.htm?type=cameras";
  debug($system_url);
  	$json = $ua->get( $system_url );
  	warn "Could not get $system_url!" unless defined $json;
  	if ($json) {
  		# Decode the entire JSON
  		$decoded = JSON->new->utf8(0)->decode( $json->decoded_content );
  		@results = @{ $decoded->{'result'} };
  		foreach my $f ( @results ) {
  				my $name=$f->{"Name"};
  				$name=~s/\s/_/;
  				$name=~s/\s/_/;
  				$name=~s/\//_/;
  				$name=~s/%/P/;
  				my $feeds={"id" => $f->{"idx"}."_cam", "name" => $name, "type" => "DevCamera", "room" => "Switches", params =>[]};
  				my $v=$f->{"ImageURL"};
  				push (@{$feeds->{'params'}}, {"key" => "localjpegurl", "value" => "$v"} );
  #				push (@{$feeds->{'params'}}, {"key" => "remotejpegurl", "value" => "$v"} );
  				push (@{$feed->{'devices'}}, $feeds );
  		}
  	}
  	#DevGenericSensor      Generic sensor (any value)
  	#Value  Current value   N/A
  
  
  
  	return($feed);
  	return { success => true};
  };
  
  sub connect_usb {
  	my $port=$_[0];
  	Device::SerialPort->new($port, 1) || die "Can't open $port: $ +!"; 
  	$ob = Device::SerialPort->new($port, 1) || die "Can't open $port: $ +!";
  	$ob->databits(8);
  	$ob->baudrate(115200);
  	$ob->parity("none");
  	$ob->stopbits(1);
  	$ob->buffers( 4096, 4096 );
  	$ob->write_settings();
  	return $ob;
  }
  
    sub connect_db {
      my $dbh = DBI->connect("dbi:SQLite:dbname=".setting('database')."?cache=shared", 
  	    "",                          
  	    "",                          
  	    { RaiseError => 1 }
  	) or die $DBI::errstr;
  
      return $dbh;
    }
  
    sub init_db {
      my $db = connect_db();
      my $schema = read_file('./schema.sql');
      $db->do($schema) or die $db->errstr;
    }
  
  init_db();  
  true;
MYSENSORS

$fatpacked{"MySensorsMSG.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MYSENSORSMSG';
  # MySensors Gateway Plugin
  # 
  # Created by epierre <epierre@e-nef.com>
  #
  # http://www.mysensors.org
  # https://github.com/empierre/arduino/
  #
  # See github for contributors
  #	
  # This program is free software; you can redistribute it and/or
  # modify it under the terms of the GNU General Public License
  # version 2 as published by the Free Software Foundation.
  package MySensorsMSG;
  use utf8;
  use Time::Piece;
  use Device::SerialPort;
  use File::Slurp;
  use IO::Handle;
  use feature     qw< unicode_strings >;
  use constant {
  	VERSION 	=> '0.2',
  	PLUGIN_NAME 	=> "MySensors Gateway Plugin",
  	PLUGIN_VERSION 	=> "1.4b1",
  	MAX_RADIO_ID	=>255,
  	NODE_CHILD_ID	=>"255",
  	BAUD_RATE 	=> "115200",
  	ARDUINO_SID 	=> "urn:upnp-arduino-cc:serviceId:arduino1",
  	VARIABLE_CONTAINER_SID => "urn:upnp-org:serviceId:VContainer1"
  };
  my $inclusionResult = {};
  my $includeCount = 0;
  #Variables in msgw can be overridded in config file
  my $InclusionMode = 0;
  my $unit = "M";
  	
  #defines
  my %msgType = (
          'PRESENTATION' => "0",
          'SET_VARIABLE' => "1",
          'REQ_VARIABLE' => "2",
  	'ACK_VARIABLE' => "3",
          'INTERNAL'     => "4",
  	'STREAMING'    => "5" );
  
  my %tDeviceLookupNumType;
  my %tDeviceTypes = (
  	'DOOR' 	=> [0, "urn:schemas-micasaverde-com:device:DoorSensor:1", "D_DoorSensor1.xml", "Door "],
  	'MOTION' 	=> [1, "urn:schemas-micasaverde-com:device:MotionSensor:1", "D_MotionSensor1.xml", "Motion "],
  	SMOKE 	=> [2, "urn:schemas-micasaverde-com:device:SmokeSensor:1", "D_SmokeSensor1.xml", "Smoke "],
  	LIGHT 	=> [3, "urn:schemas-upnp-org:device:BinaryLight:1", "D_BinaryLight1.xml", "Light "],
  	DIMMER 	=> [4, "urn:schemas-upnp-org:device:DimmableLight:1", "D_DimmableLight1.xml", "Dim Light "],
  	COVER 	=> [5, "urn:schemas-micasaverde-com:device:WindowCovering:1", "D_WindowCovering1.xml", "Win Covering "] ,
  	TEMP 	=> [6, "urn:schemas-micasaverde-com:device:TemperatureSensor:1", "D_TemperatureSensor1.xml", "Temp "],
  	HUM 	=> [7, "urn:schemas-micasaverde-com:device:HumiditySensor:1", "D_HumiditySensor1.xml", "Humidity "],
  	BARO 	=> [8, "urn:schemas-micasaverde-com:device:BarometerSensor:1", "D_BarometerSensor1.xml", "Baro "],
  	WIND 	=> [9, "urn:schemas-micasaverde-com:device:WindSensor:1", "D_WindSensor1.xml", "Wind "],
  	RAIN 	=> [10, "urn:schemas-micasaverde-com:device:RainSensor:1", "D_RainSensor1.xml", "Rain "],
  	UV 	=> [11, "urn:schemas-micasaverde-com:device:UvSensor:1", "D_UvSensor1.xml", "UV "],
  	WEIGHT 	=> [12, "urn:schemas-micasaverde-com:device:ScaleSensor:1", "D_ScaleSensor1.xml", "Weight "],
  	POWER 	=> [13, "urn:schemas-micasaverde-com:device:PowerMeter:1", "D_PowerMeter1.xml", "Power "],
  	HEATER 	=> [14, "urn:schemas-upnp-org:device:Heater:1", "D_Heater1.xml", "Heater "],
  	DISTANCE => [15, "urn:schemas-upnp-org:device:Distance:1", "D_DistanceSensor1.xml", "Distance "],
  	LIGHT_LEVEL => [16, "urn:schemas-micasaverde-com:device:LightSensor:1", "D_LightSensor1.xml", "Light "],
  	ARDUINO_NODE => [17, "urn:schemas-arduino-cc:device:arduinonode:1", "D_ArduinoNode1.xml", "Node "],
  	ARDUINO_RELAY => [18, "urn:schemas-arduino-cc:device:arduinorelay:1", "D_ArduinoRelay1.xml", "Relay "],
  	LOCK 	=> [19, "urn:micasaverde-com:serviceId:DoorLock1", "D_DoorLock1.xml", "Lock "],
  	IR 	=> [20, "urn:schemas-arduino-cc:device:ArduinoIr:1", "D_ArduinoIr1.xml", "IR "],
  	WATER 	=> [21, "urn:schemas-micasaverde-com:device:WaterMeter:1", "D_WaterMeter1.xml", "Water "]
  );
  
  my %tVarLookupNumType;
  my %tVarTypes =(
  	TEMP 	=> [0, "urn:upnp-org:serviceId:TemperatureSensor1", "CurrentTemperature", ""],
  	HUM 	=> [1, "urn:micasaverde-com:serviceId:HumiditySensor1", "CurrentLevel", ""],
  	LIGHT 	=> [2, "urn:upnp-org:serviceId:SwitchPower1", "Status", "0"] ,
  	DIMMER 	=> [3, "urn:upnp-org:serviceId:Dimming1", "LoadLevelStatus", ""],
  	PRESSURE => [4, "urn:upnp-org:serviceId:BarometerSensor1", "CurrentPressure", ""],
  	FORECAST => [5, "urn:upnp-org:serviceId:BarometerSensor1", "Forecast", ""],
  	RAIN 	=> [6, "urn:upnp-org:serviceId:RainSensor1", "CurrentTRain", ""],
  	RAINRATE => [7, "urn:upnp-org:serviceId:RainSensor1", "CurrentRain", ""],
  	WIND 	=> [8, "urn:upnp-org:serviceId:WindSensor1", "AvgSpeed", ""],
  	GUST 	=> [9, "urn:upnp-org:serviceId:WindSensor1", "GustSpeed", ""],
  	DIRECTION => [10, "urn:upnp-org:serviceId:WindSensor1", "Direction", ""],
  	UV 	=> [11, "urn:upnp-org:serviceId:UvSensor1", "CurrentLevel", ""],
  	WEIGHT 	=> [12, "urn:micasaverde-com:serviceId:ScaleSensor1", "Weight", ""],
  	DISTANCE => [13, "urn:micasaverde-com:serviceId:DistanceSensor1", "CurrentDistance", ""],
  	IMPEDANCE => [14, "urn:micasaverde-com:serviceId:ScaleSensor1", "Impedance", ""],
  	ARMED 	=> [15, "urn:micasaverde-com:serviceId:SecuritySensor1", "Armed", ""],
  	TRIPPED => [16, "urn:micasaverde-com:serviceId:SecuritySensor1", "Tripped", "0"] ,
  	WATT 	=> [17, "urn:micasaverde-com:serviceId:EnergyMetering1", "Watts", ""],
  	KWH 	=> [18, "urn:micasaverde-com:serviceId:EnergyMetering1", "KWH", "0"],
  	SCENE_ON => [19, "urn:micasaverde-com:serviceId:SceneController1", "sl_SceneActivated", ""],
  	SCENE_OFF => [20, "urn:micasaverde-com:serviceId:SceneController1", "sl_SceneDeactivated", ""],
  	HEATER 	=> [21, "urn:upnp-org:serviceId:HVAC_UserOperatingMode1", "ModeStatus", ""],
  	HEATER_SW => [22, "urn:upnp-org:serviceId:SwitchPower1", "Status", ""],
  	LIGHT_LEVEL => [23, "urn:micasaverde-com:serviceId:LightSensor1", "CurrentLevel", ""],
  	VAR_1 	=> [24, "urn:upnp-org:serviceId:VContainer1", "Variable1", ""],
  	VAR_2 	=> [25, "urn:upnp-org:serviceId:VContainer1", "Variable2", ""],
  	VAR_3 	=> [26, "urn:upnp-org:serviceId:VContainer1", "Variable3", ""],
  	VAR_4 	=> [27, "urn:upnp-org:serviceId:VContainer1", "Variable4", ""],
  	VAR_5 	=> [28, "urn:upnp-org:serviceId:VContainer1", "Variable5", ""],
  	UP 	=> [29,'','', ""],
  	DOWN 	=> [30,'','', ""],
  	STOP 	=> [31,'','', ""],
  	IR_SEND => [32,'','', ""],
  	IR_RECEIVE => [33, "urn:upnp-org:serviceId:ArduinoIr1", "IrCode", ""],
  	FLOW 	=> [34, "urn:micasaverde-com:serviceId:WaterMetering1", "Flow", ""],
  	VOLUME 	=> [35, "urn:micasaverde-com:serviceId:WaterMetering1", "Volume", "0"],
  	LOCK 	=> [36, "urn:micasaverde-com:serviceId:DoorLock1", "Status", ""]
  );
  my %tInternalLookupNumType;
  my %tInternalTypes = (
  	BATTERY_LEVEL => [0, "urn:micasaverde-com:serviceId:HaDevice1", "BatteryLevel", ""],
  	BATTERY_DATE  => [1, "urn:micasaverde-com:serviceId:HaDevice1", "BatteryDate", ""],
  	'LAST_TRIP'     => [2, "urn:micasaverde-com:serviceId:SecuritySensor1", "LastTrip", ""],
  	TIME 	      => [3,'','',''],
  	VERSION       => [4, "urn:upnp-arduino-cc:serviceId:arduinonode1", "ArduinoLibVersion", ""],
  	REQUEST_ID    => [5,'','',''],
  	INCLUSION_MODE =>[6, "urn:upnp-arduino-cc:serviceId:arduino1", "InclusionMode", "0"],
  	RELAY_NODE    => [7, "urn:upnp-arduino-cc:serviceId:arduinonode1", "RelayNode", ""],
  	LAST_UPDATE   => [8, "urn:micasaverde-com:serviceId:HaDevice1", "LastUpdate", ""],
  	PING 	      => [9,'','',''],
  	PING_ACK      => [10,'','',''],
  	LOG_MESSAGE   => [11,'','',''],
  	CHILDREN      => [12, "urn:upnp-arduino-cc:serviceId:arduinonode1", "Children", "0"],
  	UNIT          =>	[13, "urn:upnp-arduino-cc:serviceId:arduino1", "Unit", "M"], # M = Metric / I = Imperial
  	SKETCH_NAME   => [14, "urn:upnp-arduino-cc:serviceId:arduinonode1", "SketchName", ""],
  	SKETCH_VERSION => [15, "urn:upnp-arduino-cc:serviceId:arduinonode1", "SketchVersion", ""]
  );
  
  #lookup tables
  my %childIdLookupTable;
  my %availableIds;for (my $i=0;$i<254;$i++) {$availableIds[$i]=1;};
  
  while (my ($k, $v) = each %tVarTypes) {
  	$tVarLookupNumType[$v->[0]] = $k;
  }
  while (my ($k, $v) = each %tDeviceTypes) {
  	$tVarLookupNumType[$v->[0]] = $k;
  }
  while (my ($k, $v) = each %tInternalTypes) {
  	$tInternalLookupNumType[$v->[0]] = $k;
  }
  
  
  sub log {
  	my ($text,$level)=@_;
      if (! $text) {
  		print STDERR "Arduino: nil-value";
  	}else{
  		print STDERR "Arduino: $text";
  	}
  }
  sub insert_variable {
  	my $stmt = qq(INSERT INTO variable (id,type,subtype,value)
  	      VALUES ($_[0], $_[1], $_[2], $[3] ));
  	my $rv = $dbh->do($stmt) or die $DBI::errstr;
  	$sth->finish();
  }
  sub update_variable {
  	my $stmt = qq(UPDATE variable set value=$_[3] where id=$_[0] and type=$_[1] and subtype=$_[2] );
  	my $rv = $dbh->do($stmt) or die $DBI::errstr;
  	$sth->finish();
  }
  
  sub variable_set {
  my ($serviceId, $name, $deviceId, $variable)=@_;
  	my $sth = $dbh->prepare( "SELECT value FROM variable WHERE id=$deviceId AND type=$serviceId AND subtype=$name");
  	$sth->execute();
      my $row = $sth->fetch;
  	if (!$row) {
  		insert_variable($_[0],$_[1],$_[2]);
  	} else {
  		update_variable($_[0],$_[1],$_[2]); 
  	}
  }
  
  #
  # Update variable if changed
  # Return true if changed or false if no change
  #
  sub setVariableIfChanged {
  	my ($serviceId, $name, $value, $deviceId)=@_;
      &log($serviceId .",".$name.", ".$value.", ". $deviceId);
      my $curValue = &variable_get($serviceId, $name, $deviceId);
      if (($value ~= $curValue) or (! $curValue)) {
          &variable_set($serviceId, $name, $value, $deviceId);
          return true;        
      } else {
          return false;        
      }
  }
  
  sub variable_get {
  	my ($serviceId, $name, $deviceId)=@_;
  	my $sth = $dbh->prepare( "SELECT value FROM variable WHERE id=$deviceId AND type=$serviceId AND subtype=$name");
  	my($count) = $dbh->selectrow_array($sth);
      return $count;
  }
  
  sub setVariable {
  	my ($incomingData, $childId, $nodeId)=@_;
  	if ($childId){ 
  		# Set variable reported from a child sensor.
  		my $index = $incomingData->[3];
  		my $varType = $tVarLookupNumType[$index];
  		my $var = $tVarTypes[$varType];
  		my $value = $incomingData->[4];
  		if ($var->[2]) {
  			&log("setVariable: RadioId: "+$incomingData->[0]+" Sensor: "+$incomingData->[1]+" ChildId: "+$childId+" Type: " +$tVarLookupNumType[$index]+" reporting value: "+ $value);
  			&setVariableIfChanged($var->[2], $var->[3], $value, $childId);
  			# Handle special variables battery level and tripped which also
  			# should update other variables to os.time(). This part should be removed...
  			if (($varType eq "TRIPPED") and ($value eq "1")) {
  				my $variable = $tInternalTypes{'LAST_TRIP'};
  				&setVariableIfChanged($variable->[2], $variable->[3], time(), $childId);
  			} else {
  			 	my $variable = $tInternalTypes{'LAST_UPDATE'};
  				&setVariableIfChanged($variable->[2], $variable->[3], time(),$childId);
  			}
  		}
  	}
  }
  
  1;
MYSENSORSMSG

$fatpacked{"Plack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0037';
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using the PSGI stack. It contains
  middleware components, a reference server and utilities for Web
  application frameworks. Plack is like Ruby's Rack or Python's Paste
  for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that have Plack
  handlers.
  
  See L<Plack::Handler> when writing your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one L<Plack::Handler> adapter
  and run a PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  A PSGI application is a code reference but it's not easy to pass code
  reference via the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or similar, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See C<eg/dot-psgi> directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at the L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps an existing PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is a unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/plack/Plack/issues>.  Forking on
  L<github|http://github.com/plack/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  would confuse people badly.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2013 Tatsuhiko Miyagawa
  
  =head1 CORE DEVELOPERS
  
  Tatsuhiko Miyagawa (miyagawa)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Jesse Luehrs (doy)
  
  Tomas Doran (bobtfish)
  
  Graham Knop (haarg)
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  The L<PSGI> specification upon which Plack is based.
  
  L<http://plackperl.org/>
  
  The Plack wiki: L<https://github.com/plack/Plack/wiki>
  
  The Plack FAQ: L<https://github.com/plack/Plack/wiki/Faq>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util::Accessor qw( exec_cb );
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  my %exec_cache;
  
  sub would_exec {
      my($self, $file) = @_;
  
      return $exec_cache{$file} if exists $exec_cache{$file};
  
      my $exec_cb = $self->exec_cb || sub { $self->exec_cb_default(@_) };
  
      return $exec_cache{$file} = $exec_cb->($file);
  }
  
  sub exec_cb_default {
      my($self, $file) = @_;
  
      if ($file =~ /\.pl$/i) {
          return 0;
      } elsif ($self->shebang_for($file) =~ /^\#\!.*perl/) {
          return 0;
      } else {
          return 1;
      }
  }
  
  sub shebang_for {
      my($self, $file) = @_;
  
      open my $fh, "<", $file or return '';
      my $line = <$fh>;
      return $line;
  }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(
          script => $file, execute => $self->would_exec($file),
      )->to_app;
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a PSGI application.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  =head1 HOW IT WORKS
  
  This application checks if a given file path is a perl script and if
  so, uses L<CGI::Compile> to compile a CGI script into a sub (like
  L<ModPerl::Registry>) and then run it as a persistent application
  using L<CGI::Emulate::PSGI>.
  
  If the given file is not a perl script, it executes the script just
  like a normal CGI script with fork & exec. This is like a normal web
  server mode and no performance benefit is achieved.
  
  The default mechanism to determine if a given file is a Perl script is
  as follows:
  
  =over 4
  
  =item *
  
  Check if the filename ends with C<.pl>. If yes, it is a Perl script.
  
  =item *
  
  Open the file and see if the shebang (first line of the file) contains
  the word C<perl> (like C<#!/usr/bin/perl>). If yes, it is a Perl
  script.
  
  =back
  
  You can customize this behavior by passing C<exec_cb> callback, which
  takes a file path to its first argument.
  
  For example, if your perl-based CGI script uses lots of global
  variables and such and are not ready to run on a persistent
  environment, you can do:
  
    my $app = Plack::App::CGIBin->new(
        root => "/path/to/cgi-bin",
        exec_cb => sub { 1 },
    )->to_app;
  
  to always force the execute option for any files.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  # suppress output by giving the app an
                  # output spool which drops everything on the floor
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          my @try = @{$self->apps || []};
          my $tries_left = 0 + @try;
  
          if (not $tries_left) {
              return $respond->([ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ])
          }
  
          for my $app (@try) {
              my $res = $app->($env);
              if ($tries_left-- == 1) {
                  $respond_wrapper = sub { $respond->(shift) };
              }
  
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  use URI::Escape;
  use Plack::Request;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub return_dir_redirect {
      my ($self, $env) = @_;
      my $uri = Plack::Request->new($env)->uri;
      return [ 301,
          [
              'Location' => $uri . '/',
              'Content-Type' => 'text/plain',
              'Content-Length' => 8,
          ],
          [ 'Redirect' ],
      ];
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my $dir_url = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      if ($dir_url !~ m{/$}) {
          return $self->return_dir_redirect($env);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          next if $ent eq '.' or $ent eq '..';
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $dir_url . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          $url = join '/', map {uri_escape($_)} split m{/}, $url;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file content_type encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      if ($path_info) {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.SCRIPT_NAME'} =~ s/\Q$path_info\E$//;
          $env->{'plack.file.PATH_INFO'}   = $path_info;
      } else {
          $env->{'plack.file.SCRIPT_NAME'} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{'plack.file.PATH_INFO'}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
  
      if ($path =~ /\0/) {
          return $self->return_400;
      }
  
      my $docroot = $self->root || ".";
      my @path = split /[\\\/]/, $path, -1; # -1 *MUST* be here to avoid security issues!
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      if (grep /^\.{2,}$/, @path) {
          return $self->return_403;
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = $self->content_type || Plack::MIME->mime_type($file)
                         || 'text/plain';
  
      if ("CODE" eq ref $content_type) {
  		$content_type = $content_type->($file);
      }
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  sub return_400 {
      my $self = shift;
      return [400, ['Content-Type' => 'text/plain', 'Content-Length' => 11], ['Bad Request']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico')->to_app;
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =item content_type
  
  Set the file content type. If not set L<Plack::MIME> will try to detect it
  based on the file extension or fall back to C<text/plain>.
  Can be set to a callback which should work on $_[0] to check full path file 
  name.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      local @{$env}{qw(SCRIPT_NAME PATH_INFO)} = @{$env}{qw( plack.file.SCRIPT_NAME plack.file.PATH_INFO )};
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, qr/^\Q$location\E/, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..5] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $location_re, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!$location_re!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and host names (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO> (See
  L</"HOW THIS WORKS"> for details). This module is inspired by
  Ruby's Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length (longest strings
  first).
  
  URL paths need to match from the beginning and should match completely
  until the path separator (or the end of the path). For example, if you
  register the path C</foo>, it I<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it I<won't> match with C</foox>.
  
  Mapping URLs with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  Mappings will nest.  If $app is already mapped to C</baz> it will
  match a request for C</foo/baz> but not C</foo>. See L</"HOW THIS
  WORKS"> for more details.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 PERFORMANCE
  
  If you C<map> (or C<mount> with Plack::Builder) N applications,
  Plack::App::URLMap will need to at most iterate through N paths to
  match incoming requests.
  
  It is a good idea to use C<map> only for a known, limited amount of
  applications, since mounting hundreds of applications could affect
  runtime request performance.
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 HOW THIS WORKS
  
  This application works by I<fixing> C<SCRIPT_NAME> and C<PATH_INFO>
  before dispatching the incoming request to the relocated
  applications.
  
  Say you have a Wiki application that takes C</index> and C</page/*>
  and makes a PSGI application C<$wiki_app> out of it, using one of
  supported web frameworks, you can put the whole application under
  C</wiki> by:
  
    # MyWikiApp looks at PATH_INFO and handles /index and /page/*
    my $wiki_app = sub { MyWikiApp->run(@_) };
    
    use Plack::App::URLMap;
    my $app = Plack::App::URLMap->new;
    $app->mount("/wiki" => $wiki_app);
  
  When a request comes in with C<PATH_INFO> set to C</wiki/page/foo>,
  the URLMap application C<$app> strips the C</wiki> part from
  C<PATH_INFO> and B<appends> that to C<SCRIPT_NAME>.
  
  That way, if the C<$app> is mounted under the root
  (i.e. C<SCRIPT_NAME> is C<"">) with standalone web servers like
  L<Starman>, C<SCRIPT_NAME> is now locally set to C</wiki> and
  C<PATH_INFO> is changed to C</page/foo> when C<$wiki_app> gets called.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script execute _app);
  use File::Spec;
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  use POSIX ":sys_wait_h";
  
  sub slurp_fh {
      my $fh = $_[0];
      local $/;
      my $v = <$fh>;
      defined $v ? $v : '';
  }
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      $script = File::Spec->rel2abs($script);
  
      if ($self->execute) {
          my $app = sub {
              my $env = shift;
  
              pipe( my $stdoutr, my $stdoutw );
              pipe( my $stdinr,  my $stdinw );
  
  
              my $pid = fork();
              Carp::croak("fork failed: $!") unless defined $pid;
  
  
              if ($pid == 0) { # child
                  local $SIG{__DIE__} = sub {
                      print STDERR @_;
                      exit(1);
                  };
  
                  close $stdoutr;
                  close $stdinw;
  
                  local %ENV = (%ENV, CGI::Emulate::PSGI->emulate_environment($env));
  
                  open( STDOUT, ">&=" . fileno($stdoutw) )
                    or Carp::croak "Cannot dup STDOUT: $!";
                  open( STDIN, "<&=" . fileno($stdinr) )
                    or Carp::croak "Cannot dup STDIN: $!";
  
                  chdir(File::Basename::dirname($script));
                  exec($script) or Carp::croak("cannot exec: $!");
  
                  exit(2);
              }
  
              close $stdoutw;
              close $stdinr;
  
              syswrite($stdinw, slurp_fh($env->{'psgi.input'}));
              # close STDIN so child will stop waiting
              close $stdinw;
  
              my $res = '';
              while (waitpid($pid, WNOHANG) <= 0) {
                  $res .= slurp_fh($stdoutr);
              }
              $res .= slurp_fh($stdoutr);
  
              if (POSIX::WIFEXITED($?)) {
                  return CGI::Parse::PSGI::parse_cgi_output(\$res);
              } else {
                  Carp::croak("Error at run_on_shell CGI: $!");
              }
          };
          $self->_app($app);
      } else {
          my $sub = CGI::Compile->compile($script);
          my $app = CGI::Emulate::PSGI->handler($sub);
  
          $self->_app($app);
      }
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
    # if you want to execute as a real CGI script
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.rb", execute => 1)->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    my $app = Plack::App::WrapCGI->new(%args);
  
  Creates a new PSGI application using the given script. I<%args> has two
  parameters:
  
  =over 8
  
  =item script
  
  The path to a CGI-style program. This is a required parameter.
  
  =item execute
  
  An optional parameter. When set to a true value, this app will run the script
  with a CGI-style C<fork>/C<exec> model. Note that you may run programs written
  in other languages with this approach.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  use Scalar::Util ();
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub _mount {
      my ($self, $location, $app) = @_;
  
      if (!$self->{_urlmap}) {
          $self->{_urlmap} = Plack::App::URLMap->new;
      }
  
      $self->{_urlmap}->map($location => $app);
      $self->{_urlmap}; # for backward compat.
  }
  
  sub to_app {
      my($self, $app) = @_;
  
      if ($app) {
          $self->wrap($app);
      } elsif ($self->{_urlmap}) {
          $self->{_urlmap} = $self->{_urlmap}->to_app
              if Scalar::Util::blessed($self->{_urlmap});
          $self->wrap($self->{_urlmap});
      } else {
          Carp::croak("to_app() is called without mount(). No application to build.");
      }
  }
  
  sub wrap {
      my($self, $app) = @_;
  
      if ($self->{_urlmap} && $app ne $self->{_urlmap}) {
          Carp::carp("WARNING: wrap() and mount() can't be used altogether in Plack::Builder.\n" .
                     "WARNING: This causes all previous mount() mappings to be ignored.");
      }
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  
  sub mount {
      my $self = shift;
      if (Scalar::Util::blessed($self)) {
          $self->_mount(@_);
      }else{
          $_mount->($self, @_);
      }
  }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
  
      if ($mount_is_called) {
          if ($app ne $urlmap) {
              Carp::carp("WARNING: You used mount() in a builder block, but the last line (app) isn't using mount().\n" .
                         "WARNING: This causes all mount() mappings to be ignored.\n");
          } else {
              $app = $app->to_app;
          }
      }
  
      $app = $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Deflater";
        enable "Session", store => "File";
        enable "Debug", panels => [ qw(DBITrace Memory Timer) ];
        enable "+My::Plack::Middleware";
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
    # using OO interface
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->add_middleware('Bar');
    $builder->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with L<Plack::Middleware> subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<enable> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler. C<"Plack::Middleware::">
  is added as a prefix by default. So:
  
    builder {
        enable "Foo";
        enable "Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<enable> middleware from outer to inner.
  
  =head1 INLINE MIDDLEWARE
  
  Plack::Builder allows you to code middleware inline using a nested
  code reference.
  
  If the first argument to C<enable> is a code reference, it will be
  passed an C<$app> and should return another code reference
  which is a PSGI application that consumes C<$env> at runtime. So:
  
    builder {
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                # do preprocessing
                my $res = $app->($env);
                # do postprocessing
                return $res;
            };
        };
        $app;
    };
  
  is equal to:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> via the C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  C<builder> you can't use C<map> as a DSL, for the obvious reason :)
  
  B<NOTE>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    my $app = sub {
        my $env = shift;
        ...
    };
  
    builder {
        mount "/foo" => sub { ... };
        $app; # THIS DOESN'T WORK
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored. Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
    builder {
        mount "/foo" => sub { ... };
        mount "/" => $app;
    }
  
  Note that the C<builder> DSL returns a whole new PSGI application, which means
  
  =over 4
  
  =item *
  
  C<builder { ... }> should normally the last statement of a C<.psgi>
  file, because the return value of C<builder> is the application that
  is actually executed.
  
  =item *
  
  You can nest your C<builder> blocks, mixed with C<mount> statements (see L</"URLMap support">
  above):
  
    builder {
        mount "/foo" => builder {
            mount "/bar" => $app;
        }
    }
  
  will locate the C<$app> under C</foo/bar>, since the inner C<builder>
  block puts it under C</bar> and it results in a new PSGI application
  which is located under C</foo> because of the outer C<builder> block.
  
  =back
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment.
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
  See L<Plack::Middleware::Conditional> for details.
  
  =head1 OBJECT ORIENTED INTERFACE
  
  Object oriented interface supports the same functionality with the DSL
  version in a clearer interface, probably with more typing required.
  
    # With mount
    my $builder = Plack::Builder->new;
    $builder->add_middleware('Foo', opt => 1);
    $builder->mount('/foo' => $foo_app);
    $builder->mount('/' => $root_app);
    $builder->to_app;
  
    # Nested builders. Equivalent to:
    # builder {
    #     mount '/foo' => builder {
    #         enable 'Foo';
    #         $app;
    #     };
    #     mount '/' => $app2;
    # };
    my $builder_out = Plack::Builder->new;
    my $builder_in  = Plack::Builder->new;
    $builder_in->add_middleware('Foo');
    $builder_out->mount("/foo" => $builder_in->wrap($app));
    $builder_out->mount("/" => $app2);
    $builder_out->to_app;
  
    # conditional. You can also directly use Plack::Middleware::Conditional
    my $builder = Plack::Builder->new;
    $builder->add_middleware_if(sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' }, 'StackTrace');
    $builder->wrap($app);
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => \&to_app_auto, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  sub to_app_auto {
      my $self = shift;
      if (($ENV{PLACK_ENV} || '') eq 'development') {
          my $class = ref($self);
          warn "WARNING: Automatically converting $class instance to a PSGI code reference. " .
            "If you see this warning for each request, you probably need to explicitly call " .
            "to_app() i.e. $class->new(...)->to_app in your PSGI file.\n";
      }
      $self->to_app(@_);
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
      Plack::Util::response_cb($res, $cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between L<Plack::Middleware>
  and C<Plack::App::*> modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This
  is where all the work gets done. It receives the PSGI C<$env> hash-ref
  as an argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hashref and uses that to
  create the instance. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method; it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =item response_cb
  
  This is a wrapper for C<response_cb> in L<Plack::Util>. See
  L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =head1 OBJECT LIFECYCLE
  
  Objects for the derived classes (Plack::App::* or
  Plack::Middleware::*) are created at the PSGI application compile
  phase using C<new>, C<prepare_app> and C<to_app>, and the created
  object persists during the web server lifecycle, unless it is running
  on the non-persistent environment like CGI. C<call> is invoked against
  the same object whenever a new request comes in.
  
  You can check if it is running in a persistent environment by checking
  C<psgi.run_once> key in the C<$env> being true (non-persistent) or
  false (persistent), but it is best for you to write your middleware
  safely for a persistent environment. To accomplish that, you should
  avoid saving per-request data like C<$env> in your object.
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  If you want to force the use of the slower pure perl version even if the
  fast XS version is available, set the environment variable
  C<PLACK_HTTP_PARSER_PP> to 1.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      for ($path, $query) { s/\#.*$// if defined && length } # dumb clients sending URI fragments
  
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
          'psgix.harakiri'      => Plack::Util::TRUE,
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      my $vpath    = $env->{SCRIPT_NAME} . ($env->{PATH_INFO} || '');
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if ($env->{'psgix.harakiri.commit'}) {
          $r->child_terminate;
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x mod_perl handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use Apache2::Log;
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  use URI;
  use URI::Escape;
  
  my %apps; # psgi file to $app mapping
  
  sub new { bless {}, shift }
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          # Trick Catalyst, CGI.pm, CGI::Cookie and others that check
          # for $ENV{MOD_PERL}.
          #
          # Note that we delete it instead of just localizing
          # $ENV{MOD_PERL} because some users may check if the key
          # exists, and we do it this way because "delete local" is new
          # in 5.12:
          # http://perldoc.perl.org/5.12.0/perldelta.html#delete-local
          local $ENV{MOD_PERL};
          delete $ENV{MOD_PERL};
  
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'           => [ 1, 1 ],
          'psgi.url_scheme'        => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'             => $r,
          'psgi.errors'            => *STDERR,
          'psgi.multithread'       => Plack::Util::FALSE,
          'psgi.multiprocess'      => Plack::Util::TRUE,
          'psgi.run_once'          => Plack::Util::FALSE,
          'psgi.streaming'         => Plack::Util::TRUE,
          'psgi.nonblocking'       => Plack::Util::FALSE,
          'psgix.harakiri'         => Plack::Util::TRUE,
          'psgix.cleanup'          => Plack::Util::TRUE,
          'psgix.cleanup.handlers' => [],
      };
  
      if (defined(my $HTTP_AUTHORIZATION = $r->headers_in->{Authorization})) {
          $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
      }
  
      # If you supply more than one Content-Length header Apache will
      # happily concat the values with ", ", e.g. "72, 72". This
      # violates the PSGI spec so fix this up and just take the first
      # one.
      if (exists $env->{CONTENT_LENGTH} && $env->{CONTENT_LENGTH} =~ /,/) {
          no warnings qw(numeric);
          $env->{CONTENT_LENGTH} = int $env->{CONTENT_LENGTH};
      }
  
      # Actually, we can not trust PATH_INFO from mod_perl because mod_perl squeezes multiple slashes into one slash.
      my $uri = URI->new("http://".$r->hostname.$r->unparsed_uri);
  
      $env->{PATH_INFO} = uri_unescape($uri->path);
  
      $class->fixup_path($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      if (@{ $env->{'psgix.cleanup.handlers'} }) {
          $r->push_handlers(
              PerlCleanupHandler => sub {
                  for my $cleanup_handler (@{ $env->{'psgix.cleanup.handlers'} }) {
                      $cleanup_handler->($env);
                  }
  
                  if ($env->{'psgix.harakiri.commit'}) {
                      $r->child_terminate;
                  }
              },
          );
      } else {
          if ($env->{'psgix.harakiri.commit'}) {
              $r->child_terminate;
          }
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Registry to override.
  sub fixup_path {
      my ($class, $r, $env) = @_;
  
      # $env->{PATH_INFO} is created from unparsed_uri so it is raw.
      my $path_info = $env->{PATH_INFO} || '';
  
      # Get argument of <Location> or <LocationMatch> directive
      # This may be string or regexp and we can't know either.
      my $location = $r->location;
  
      # Let's *guess* if we're in a LocationMatch directive
      if ($location eq '/') {
          # <Location /> could be handled as a 'root' case where we make
          # everything PATH_INFO and empty SCRIPT_NAME as in the PSGI spec
          $env->{SCRIPT_NAME} = '';
      } elsif ($path_info =~ s{^($location)/?}{/}) {
          $env->{SCRIPT_NAME} = $1 || '';
      } else {
          # Apache's <Location> is matched but here is not.
          # This is something wrong. We can only respect original.
          $r->server->log_error(
              "Your request path is '$path_info' and it doesn't match your Location(Match) '$location'. " .
              "This should be due to the configuration error. See perldoc Plack::Handler::Apache2 for details."
          );
      }
  
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 mod_perl handler to run PSGI application
  
  =head1 SYNOPSIS
  
    # in your httpd.conf
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optionally preload your apps in startup
    PerlPostConfigRequire /etc/httpd/startup.pl
  
  See L</STARTUP FILE> for more details on writing a C<startup.pl>.
  
  =head1 DESCRIPTION
  
  This is a mod_perl handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  If you want to run PSGI applications I<behind> Apache instead of using
  mod_perl, see L<Plack::Handler::FCGI> to run with FastCGI, or use
  standalone HTTP servers such as L<Starman> or L<Starlet> proxied with
  mod_proxy.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 STARTUP FILE
  
  Here is an example C<startup.pl> to preload PSGI applications:
  
      #!/usr/bin/env perl
  
      use strict;
      use warnings;
      use Apache2::ServerUtil ();
  
      BEGIN {
          return unless Apache2::ServerUtil::restart_count() > 1;
  
          require lib;
          lib->import('/path/to/my/perl/libs');
  
          require Plack::Handler::Apache2;
  
          my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
          foreach my $psgi (@psgis) {
              Plack::Handler::Apache2->preload($psgi);
          }
      }
  
      1; # file must return true!
  
  See L<http://perl.apache.org/docs/2.0/user/handlers/server.html#Startup_File>
  for general information on the C<startup.pl> file for preloading perl modules
  and your apps.
  
  Some things to keep in mind when writing this file:
  
  =over 4
  
  =item * multiple init phases
  
  You have to check that L<Apache2::ServerUtil/restart_count> is C<< > 1 >>,
  otherwise your app will load twice and the env vars you set with
  L<PerlSetEnv|http://perl.apache.org/docs/2.0/user/config/config.html#C_PerlSetEnv_>
  will not be available when your app is loading the first time.
  
  Use the example above as a template.
  
  =item * C<@INC>
  
  The C<startup.pl> file is a good place to add entries to your C<@INC>.
  Use L<lib> to add entries, they can be in your app or C<.psgi> as well, but if
  your modules are in a L<local::lib> or some such, you will need to add the path
  for anything to load.
  
  Alternately, if you follow the example above, you can use:
  
      PerlSetEnv PERL5LIB /some/path
  
  or
  
      PerlSwitches -I/some/path
  
  in your C<httpd.conf>, which will also work.
  
  =item * loading errors
  
  Any exceptions thrown in your C<startup.pl> will stop Apache from starting at
  all.
  
  You probably don't want a stray syntax error to bring your whole server down in
  a shared or development environment, in which case it's a good idea to wrap the
  L</preload> call in an eval, using something like this:
  
      require Plack::Handler::Apache2;
  
      my @psgis = ('/path/to/app1.psgi', '/path/to/app2.psgi');
  
      foreach my $psgi (@psgis) {
          eval {
              Plack::Handler::Apache2->preload($psgi); 1;
          } or do {
              my $error = $@ || 'Unknown Error';
              # STDERR goes to the error_log
              print STDERR "Failed to load psgi '$psgi': $error\n";
          };
      }
  
  
  =item * dynamically loaded modules
  
  Some modules load their dependencies at runtime via e.g. L<Class::Load>. These
  modules will not get preloaded into your parent process by just including the
  app/module you are using.
  
  As an optimization, you can dump C<%INC> from a request to see if you are using
  any such modules and preload them in your C<startup.pl>.
  
  Another method is dumping the difference between the C<%INC> on
  process start and process exit. You can use something like this to
  accomplish this:
  
      my $start_inc = { %INC };
  
      END {
          my @m;
          foreach my $m (keys %INC) {
              push @m, $m unless exists $start_inc->{$m};
          }
  
          if (@m) {
              # STDERR goes to the error_log
              print STDERR "The following modules need to be preloaded:\n";
              print STDERR "$_\n" for @m;
          }
      }
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  Ævar Arnfjörð Bjarmason
  
  Rafael Kitover
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub fixup_path {
      my ($class, $r, $env) = @_;
      $env->{PATH_INFO} =~ s{^$env->{SCRIPT_NAME}}{};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  # copied from HTTP::Status
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = $self->setup_env();
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub setup_env {
      my ( $self, $override_env ) = @_;
  
      $override_env ||= {};
  
      binmode STDIN;
      binmode STDERR;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
          %{ $override_env },
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      return $env;
  }
  
  
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
      binmode STDOUT;
  
      my $hdrs;
      my $message = $StatusCode{$res->[0]};
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 UTILITY METHODS
  
  =head2 setup_env()
  
    my $env = Plack::Handler::CGI->setup_env();
    my $env = Plack::Handler::CGI->setup_env(\%override_env);
  
  Sets up the PSGI environment hash for a CGI request from C<< %ENV >>> and returns it.
  You can provide a hashref of key/value pairs to override the defaults if you would like.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Scalar::Util qw(blessed);
  use Plack::Util;
  use FCGI;
  use HTTP::Status qw(status_message);
  use URI;
  use URI::Escape;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1 unless blessed $self->{manager};
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{backlog}     ||= 100;
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $running_on_server_starter = exists $ENV{SERVER_STARTER_PORT};
      my $sock = 0;
      if (-S STDIN) {
          # running from web server. Do nothing
          # Note it should come before listen check because of plackup's default
      } elsif ($running_on_server_starter) {
          # Runing under Server::Starter
          require Server::Starter;
          my %socks = %{Server::Starter::server_ports()};
          if (scalar(keys(%socks)) > 1) {
              die "More than one socket are specified by Server::Starter";
          }
          $sock = (values %socks)[0];
      } elsif ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], $self->{backlog} )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      } elsif (!RUNNING_IN_HELL) {
          die "STDIN is not a socket: specify a listen location";
      }
  
      @{$self}{qw(stdin stdout stderr)} 
        = (IO::Handle->new, IO::Handle->new, IO::Handle->new);
  
      my %env;
      my $request = FCGI::Request(
          $self->{stdin}, $self->{stdout}, $self->{stderr},
          \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen} or $running_on_server_starter) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              if (blessed $self->{manager}) {
                  for (qw(nproc pid proc_title)) {
                      die "Don't use '$_' when passing in a 'manager' object"
                          if $self->{$_};
                  }
                  $proc_manager = $self->{manager};
              } else {
                  Plack::Util::load_class($self->{manager});
                  $proc_manager = $self->{manager}->new({
                      n_processes => $self->{nproc},
                      pid_fname   => $self->{pid},
                      (exists $self->{proc_title}
                           ? (pm_title => $self->{proc_title}) : ()),
                  });
              }
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => $self->{stdin},
              'psgi.errors'       => 
                  ($self->{keep_stderr} ? \*STDERR : $self->{stderr}),
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => defined $proc_manager,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
              'psgix.harakiri'    => defined $proc_manager,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          # lighttpd munges multiple slashes in PATH_INFO into one. Try recovering it
          my $uri = URI->new("http://localhost" .  $env->{REQUEST_URI});
          $env->{PATH_INFO} = uri_unescape($uri->path);
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E//;
  
          # root access for mod_fastcgi
          if (!exists $env->{PATH_INFO}) {
              $env->{PATH_INFO} = '';
          }
  
          # typical fastcgi_param from nginx might get empty values
          for my $key (qw(CONTENT_TYPE CONTENT_LENGTH)) {
              no warnings;
              delete $env->{$key} if exists $env->{$key} && $env->{$key} eq '';
          }
  
          if (defined(my $HTTP_AUTHORIZATION = $env->{Authorization})) {
              $env->{HTTP_AUTHORIZATION} = $HTTP_AUTHORIZATION;
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          # give pm_post_dispatch the chance to do things after the client thinks
          # the request is done
          $request->Finish;
  
          $proc_manager && $proc_manager->pm_post_dispatch();
  
          if ($proc_manager && $env->{'psgix.harakiri.commit'}) {
              $proc_manager->pm_exit("safe exit with harakiri");
          }
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      $self->{stdout}->autoflush(1);
      binmode $self->{stdout};
  
      my $hdrs;
      my $message = status_message($res->[0]);
      $hdrs = "Status: $res->[0] $message\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print { $self->{stdout} } $hdrs;
  
      my $cb = sub { print { $self->{stdout} } $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => [ $port_or_socket ],
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => [ '/path/to/socket' ]
      listen => [ ':8080' ]
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify either a FCGI::ProcManager subclass, or an actual FCGI::ProcManager-compatible object.
  If you do not want a FCGI::ProcManager but instead run in a single process, set this to undef.
  
    use FCGI::ProcManager::Dynamic;
    Plack::Handler::FCGI->new(
        manager => FCGI::ProcManager::Dynamic->new(...),
    );
  
  =item daemonize
  
  Daemonize the process.
  
  =item proc-title
  
  Specify process title
  
  =item keep-stderr
  
  Send psgi.errors to STDERR instead of to the FCGI error stream.
  
  =item backlog
  
  Maximum length of the queue of pending connections
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  In all cases, you will want to install L<FCGI> and L<FCGI::ProcManager>.
  You may find it most convenient to simply install L<Task::Plack> which
  includes both of these.
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SERVER_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  After installing C<mod_fastcgi>, you should add the C<FastCgiExternalServer>
  directive to your Apache config:
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
    ## Then set up the location that you want to be handled by fastcgi:
  
    # EITHER from a given path
    Alias /myapp/ /tmp/myapp.fcgi/
  
    # OR at the root
    Alias / /tmp/myapp.fcgi/
  
  Now you can use plackup to listen to the socket that you've just configured in Apache.
  
    $  plackup -s FCGI --listen /tmp/myapp.sock psgi/myapp.psgi
  
  The above describes the "standalone" method, which is usually appropriate.
  There are other methods, described in more detail at 
  L<Catalyst::Engine::FastCGI/Standalone_server_mode> (with regards to Catalyst, but which may be set up similarly for Plack).
  
  See also L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer>
  for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable",
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mounting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mounting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1",
         "port" = "5000",
         "check-local" => "disable",
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head2 Authorization
  
  Most fastcgi configuration does not pass C<Authorization> headers to
  C<HTTP_AUTHORIZATION> environment variable by default for security
  reasons. Authentication middleware such as L<Plack::Middleware::Auth::Basic> or
  L<Catalyst::Authentication::Credential::HTTP> requires the variable to
  be set up. Plack::Handler::FCGI supports extracting the C<Authorization> environment
  variable when it is configured that way.
  
  Apache2 with mod_fastcgi:
  
    --pass-header Authorization
  
  mod_fcgid:
  
    FcgiPassHeader Authorization
  
  =head2 Server::Starter
  
  This plack handler supports L<Server::Starter> as a superdaemon.
  Simply launch plackup from start_server with a path option.
  The listen option is ignored when launched from Server::Starter.
  
    start_server --path=/tmp/socket -- plackup -s FCGI app.psgi 
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/Standalone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/LWPish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LWPISH';
  package Plack::LWPish;
  use strict;
  use warnings;
  use HTTP::Tiny;
  use HTTP::Response;
  use Hash::MultiValue;
  
  sub new {
      my $class = shift;
      my $self  = bless {}, $class;
      $self->{http} = @_ == 1 ? $_[0] : HTTP::Tiny->new(@_);
      $self;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my @headers;
      $req->headers->scan(sub { push @headers, @_ });
  
      my $options = {
          headers => Hash::MultiValue->new(@headers)->mixed,
      };
      $options->{content} = $req->content if defined $req->content && length($req->content);
  
      my $response = $self->{http}->request($req->method, $req->url, $options);
  
      my $res = HTTP::Response->new(
          $response->{status},
          $response->{reason},
          [ Hash::MultiValue->from_mixed($response->{headers})->flatten ],
          $response->{content},
      );
      $res->request($req);
  
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::LWPish - HTTP::Request/Response compatible interface with HTTP::Tiny backend
  
  =head1 SYNOPSIS
  
    use Plack::LWPish;
  
    my $request = HTTP::Request->new(GET => 'http://perl.com/');
  
    my $ua = Plack::LWPish->new;
    my $res = $ua->request($request); # returns HTTP::Response
  
  =head1 DESCRIPTION
  
  This module is an adapter object that implements one method,
  C<request> that acts like L<LWP::UserAgent>'s request method
  i.e. takes HTTP::Request object and returns HTTP::Response object.
  
  This module is used solely inside L<Plack::Test::Suite> and
  L<Plack::Test::Server>, and you are recommended to take a look at
  L<HTTP::Thin> if you would like to use this outside Plack.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Thin> L<HTTP::Tiny> L<LWP::UserAgent>
  
  =cut
PLACK_LWPISH

$fatpacked{"Plack/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          if (($ENV{PLACK_ENV}||'') eq 'development' or !/^Can't locate /) {
              warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
                  "(You might need to install Plack::Handler::$backend from CPAN.  Caught error was: $_)\n"
                      if $ENV{PLACK_ENV} && $ENV{PLACK_ENV} eq 'development';
          }
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      try {
          $server_class = Plack::Util::load_class($server, 'Plack::Handler');
      } catch {
          $error ||= $_;
      };
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      my $env = $class->env;
  
      return $env->{PLACK_SERVER} if $env->{PLACK_SERVER};
  
      if ($env->{PHP_FCGI_CHILDREN} || $env->{FCGI_ROLE} || $env->{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($env->{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } else {
          return "Standalone";
      }
  }
  
  sub env { \%ENV }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro> or L<POE> is loaded, the relevant
  server implementation such as L<Twiggy>, L<Corona> or
  L<POE::Component::Server::PSGI> will be loaded, if they're available.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      delete $self->{pid}; # re-init in case it's a restart
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      if ($pid == 0) { # child
          return $server->run($self->{builder}->());
      } else {
          $self->{pid} = $pid;
      }
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
  }
  
  sub valid_file {
      my($self, $file) = @_;
  
      # vim temporary file is  4913 to 5036
      # http://www.mail-archive.com/vim_dev@googlegroups.com/msg07518.html
      if ( $file->{path} =~ m{(\d+)$} && $1 >= 4913 && $1 <= 5036) {
          return 0;
      }
      $file->{path} !~ m!\.(?:git|svn)[/\\]|\.(?:bak|swp|swpx|swx)$|~$|_flymake\.p[lm]$|\.#!;
  }
  
  sub run {
      my($self, $server) = @_;
  
      $self->_fork_and_start($server);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
      local $SIG{TERM} = sub { $self->_kill_child; exit(0); };
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          warn "Successfully killed! Restarting the new server process.\n";
          $self->_fork_and_start($server);
          return unless $self->{pid};
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  die <<DIE if $^O eq 'MSWin32' && !$ENV{PLACK_SHOTGUN_MEMORY_LEAK};
  
  Shotgun loader uses fork(2) system call to create a fresh Perl interpreter, that is known to not work
  properly in a fork-emulation layer on Windows and cause huge memory leaks.
  
  If you're aware of this and still want to run the loader, run it with the environment variable
  PLACK_SHOTGUN_MEMORY_LEAK on.
  
  DIE
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTION
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".webm"    => "video/webm",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".woff"    => "application/font-woff",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is a utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or the C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  Your middleware object is created at the PSGI application compile time
  and is persistent during the web server life cycle (unless it is a
  non-persistent environment such as CGI), so you should never set or
  cache per-request data like C<$env> in your middleware object. See
  also L<Plack::Component/"OBJECT LIFECYCLE">.
  
  See L<Plack::Builder> how to actually enable middleware in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use the C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 RESPONSE CALLBACK
  
  The typical middleware is written like this:
  
    package Plack::Middleware::Something;
    use parent qw(Plack::Middleware);
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $self->app->($env);
        # post-processing $res
        return $res;
    }
  
  The tricky thing about post-processing the response is that it could
  either be an immediate 3 element array ref, or a code reference that
  implements the delayed (streaming) interface.
  
  Dealing with these two types of response in each piece of middleware
  is pointless, so you're recommended to use the C<response_cb> wrapper
  function in L<Plack::Util> when implementing a post processing
  middleware.
  
    sub call {
        my($self, $env) = @_;
        # pre-processing $env
        my $res = $app->($env);
  
        return Plack::Util::response_cb($res, sub {
            my $res = shift;
            # do something with $res;
        });
    }
  
  The callback function gets a response as an array reference, and you can
  update the reference to implement the post-processing. In the normal
  case, this arrayref will have three elements (as described by the PSGI
  spec), but will have only two elements when using a C<$writer> as
  described below.
  
    package Plack::Middleware::Always500;
    use parent qw(Plack::Middleware);
    use Plack::Util;
  
    sub call {
        my($self, $env) = @_;
        my $res  = $self->app->($env);
        return Plack::Util::response_cb($res, sub {
            my $res = shift;
            $res->[0] = 500;
            return;
        });
    }
  
  In this example, the callback gets the C<$res> and updates its first
  element (status code) to 500. Using C<response_cb> makes sure that
  this works with the delayed response too.
  
  You're not required (and not recommended either) to return a new array
  reference - they will be simply ignored. You're suggested to
  explicitly return, unless you fiddle with the content filter callback
  (see below).
  
  Similarly, note that you have to keep the C<$res> reference when you
  swap the entire response.
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        $res = [ $new_status, $new_headers, $new_body ]; # THIS DOES NOT WORK
        return;
    });
  
  This does not work, since assigning a new anonymous array to C<$res>
  doesn't update the original PSGI response value. You should instead
  do:
  
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        @$res = ($new_status, $new_headers, $new_body); # THIS WORKS
        return;
    });
  
  The third element of the response array ref is a body, and it could
  be either an arrayref or L<IO::Handle>-ish object. The application could
  also make use of the C<$writer> object if C<psgi.streaming> is in
  effect, and in this case, the third element will not exist
  (C<@$res == 2>). Dealing with these variants is again really painful,
  and C<response_cb> can take care of that too, by allowing you to return
  a content filter as a code reference.
  
    # replace all "Foo" in content body with "Bar"
    Plack::Util::response_cb($res, sub {
        my $res = shift;
        return sub {
            my $chunk = shift;
            return unless defined $chunk;
            $chunk =~ s/Foo/Bar/g;
            return $chunk;
        }
    });
  
  The callback takes one argument C<$chunk> and your callback is
  expected to return the updated chunk. If the given C<$chunk> is undef,
  it means the stream has reached the end, so your callback should also
  return undef, or return the final chunk and return undef when called
  next time.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Component>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format compiled_format);
  use Apache::LogFormat::Compiler;
  
  my %formats = (
      common => '%h %l %u %t "%r" %>s %b',
      combined => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"',
  );
  
  sub prepare_app {
      my $self = shift;
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
      $self->compiled_format(Apache::LogFormat::Compiler->new($fmt));
  }
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      if ( ref($res) && ref($res) eq 'ARRAY' ) {
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
          return $res;
      }
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $content_length = Plack::Util::content_length($res->[2]);
          my $log_line = $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length });
          if ( my $logger = $self->logger ) {
              $logger->($log_line);
          }
          else {
              $env->{'psgi.errors'}->print($log_line);
          }  
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      $self->compiled_format->log_line(
          $env,
          [$status,$headers],
          $opts->{content_length},
          $opts->{time}
      );
  }
  
  1;
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats). If none is specified C<combined> is
  used.
  
  This middleware uses calculable Content-Length by checking body type,
  and cannot log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"';
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware uses L<Apache::LogFormat::Compiler> to
  generate access_log lines. See more details on perldoc L<Apache::LogFormat::Compiler>
  
     %%    a percent sign
     %h    REMOTE_ADDR from the PSGI environment, or -
     %l    remote logname not implemented (currently always -)
     %u    REMOTE_USER from the PSGI environment, or -
     %t    [local timestamp, in default format]
     %r    REQUEST_METHOD, REQUEST_URI and SERVER_PROTOCOL from the PSGI environment
     %s    the HTTP status code of the response
     %b    content length of the response
     %T    custom field for handling times in subclasses
     %D    custom field for handling sub-second times in subclasses
     %v    SERVER_NAME from the PSGI environment, or -
     %V    HTTP_HOST or SERVER_NAME from the PSGI environment, or -
     %p    SERVER_PORT from the PSGI environment
     %P    the worker's process id
     %m    REQUEST_METHOD from the PSGI environment
     %U    PATH_INFO from the PSGI environment
     %q    QUERY_STRING from the PSGI environment
     %H    SERVER_PROTOCOL from the PSGI environment
  
  Some of these format fields are only supported by middleware that subclasses C<AccessLog>.
  
  In addition, custom values can be referenced, using C<%{name}>,
  with one of the mandatory modifier flags C<i>, C<o> or C<t>:
  
     %{variable-name}i    HTTP_VARIABLE_NAME value from the PSGI environment
     %{header-name}o      header-name header in the response
     %{time-format]t      localtime in the specified strftime format
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(level => 'debug', message => @_) };
  
  Sets a callback to print log message to. It prints to the C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Nagano
  
  =head1 SEE ALSO
  
  L<Apache::LogFormat::Compiler>, L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              my $length;
  
              return sub {
                  my $line = shift;
                  
                  $length += length $line if defined $line;
  
                  unless( defined $line ) {
                      my $now = Time::HiRes::gettimeofday;
                      $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
                  }
  
                  return $line;
              };
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => "%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  L<Plack::Middleware::AccessLog> but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream to capture the time taken
  for the PSGI server to read the whole response body.
  
  This would mean, if the middleware is in use, it will prevent some
  server-side optimizations like sendfile(2) from working, as well as
  middleware like L<Plack::Middleware::ContentLength> can't guess the
  body size out of the file handle.
  
  If all you want is to capture the time taken in your PSGI application
  and do not want the wrapped body behavior described above, consider instead
  applying L<Plack::Middleware::Runtime> and using L<Plack::Middleware::AccessLog>
  to log the C<X-Runtime> header.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  L<Plack::Middleware::Runtime>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_[0,1]) }); # because Authen::Simple barfs on 3 params
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      # note the 'i' on the regex, as, according to RFC2617 this is a 
      # "case-insensitive token to identify the authentication scheme"
      if ($auth =~ /^Basic (.*)$/i) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":"), 2;
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass, $env)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password, $env) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username, password and PSGI environment
  supplied and returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via Apache's mod_cgi), this middleware
  does not work since your application can't know the value of
  C<Authorization:> header.
  
  If you use Apache as a web server and CGI to run your PSGI
  application, you can either a) compile Apache with
  C<-DSECURITY_HOLE_PASS_AUTHORIZATION> option, or b) use mod_rewrite to
  pass the Authorization header to the application with the rewrite rule
  like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Plack::Util::Accessor qw(force);
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming && !$self->force;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface, unless you set C<force>
  option (see below).
  
  =head1 OPTIONS
  
  =over 4
  
  =item force
  
  Force enable this middleware only if the container supports C<psgi.streaming>.
  
  =back
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub prepare_app {
      my $self = shift;
      $self->middleware( $self->builder->($self->app) );
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace', force => 1;
        $app;
    };
  
    # or using the OO interface:
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' },
        builder => sub { Plack::Middleware::StackTrace->wrap($_[0], force => 1) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under runtime conditions. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> conditions, which is
  from outer to inner: that is, from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              if ($res->[2]) {
                  $res->[2] = [];
              } else {
                  return sub {
                      return defined $_[0] ? '' : undef;
                  };
              }
          }
      });
  }
  
  no warnings 'uninitialized';
  
  # RFC 2616 14.25 says it's OK and expected to use 'eq' :)
  # > Note: When handling an If-Modified-Since header field, some
  # > servers will use an exact date comparison function, rather than a
  # > less-than function, for deciding whether to send a 304 ...
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to enable conditional GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  if (@$r == 3) {
                      $r->[2] = $sub_r->[2];
                  }
                  else {
                      my $full_sub_response = '';
                      Plack::Util::foreach($sub_r->[2], sub {
                          $full_sub_response .= $_[0];
                      });
  
                      my $returned;
                      return sub {
                          if ($returned) {
                              return defined($_[0]) ? '' : undef;
                          }
                          $returned = 1;
                          return $full_sub_response;
                      }
                  }
              }
              # TODO: allow 302 here?
          } else {
              my $h = Plack::Util::headers($r->[1]);
              $h->remove('Content-Length');
              $h->remove('Content-Encoding');
              $h->remove('Transfer-Encoding');
              $h->set('Content-Type', Plack::MIME->mime_type($path));
  
              open my $fh, "<", $path or die "$path: $!";
              if ($r->[2]) {
                  $r->[2] = $fh;
              } else {
                  my $done;
                  return sub {
                      unless ($done) {
                          $done = 1;
                          return join '', <$fh>;
                      }
                      return defined $_[0] ? '' : undef;
                  };
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  When using a subrequest, the subrequest should return a regular '200' response.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(rethrow);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub prepare_app {
      my $self = shift;
      $self->rethrow(1) if ($ENV{PLACK_ENV} || '') eq 'development';
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('as_psgi')) {
          return $e->as_psgi;
      }
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          if ($self->rethrow) {
              die $e;
          }
          else {
              $code = 500;
              $env->{'psgi.errors'}->print($e);
          }
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      my @headers = (
           'Content-Type'   => 'text/plain',
           'Content-Length' => length($message),
      );
  
      if ($code =~ /^3/ && (my $loc = eval { $e->location })) {
          push(@headers, Location => $loc);
      }
  
      return [ $code, \@headers, [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions", rethrow => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applications that can be translated into HTTP
  status codes.
  
  Your application is supposed to throw an object that implements a
  C<code> method which returns the HTTP status code, such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code. If the C<code> method returns a code that is not an HTTP
  redirect or error code (3xx, 4xx, or 5xx), the exception will be
  rethrown.
  
  The exception object may also implement C<as_string> or overload
  stringification to represent the text of the error. The text defaults to
  the status message of the error code, such as I<Service Unavailable> for
  C<503>.
  
  Finally, the exception object may implement C<as_psgi>, and the result
  of this will be returned directly as the PSGI response.
  
  If the code is in the 3xx range and the exception implements the 'location'
  method (HTTP::Exception::3xx does), the Location header will be set in the
  response, so you can do redirects this way.
  
  There are CPAN modules L<HTTP::Exception> and L<HTTP::Throwable>, and
  they are perfect to throw from your application to let this middleware
  catch and display, but you can also implement your own exception class
  to throw.
  
  If the thrown exception is not an object that implements either a
  C<code> or an C<as_psgi> method, a 500 error will be returned, and the
  exception is printed to the psgi.errors stream.
  Alternatively, you can pass a true value for the C<rethrow> parameter
  for this middleware, and the exception will instead be rethrown. This is
  enabled by default when C<PLACK_ENV> is set to C<development>, so that
  the L<StackTrace|Plack::Middleware::StackTrace> middleware can catch it
  instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception> L<HTTP::Throwable>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          if ($res->[2]) {
              $res->[2] = [];
          } else {
              return sub {
                  return defined $_[0] ? '': undef;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/IIS6ScriptNameFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX';
  package Plack::Middleware::IIS6ScriptNameFix;
  
  use strict;
  use parent 'Plack::Middleware';
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /IIS\/[6-9]\.[0-9]/) {
          my @script_name = split(m!/!, $env->{PATH_INFO});
          my @path_translated = split(m!/|\\\\?!, $env->{PATH_TRANSLATED});
          my @path_info;
  
          while ($script_name[$#script_name] eq $path_translated[$#path_translated]) {
              pop(@path_translated);
              unshift(@path_info, pop(@script_name));
          }
  
          unshift(@path_info, '', '');
  
          $env->{PATH_INFO} = join('/', @path_info);
          $env->{SCRIPT_NAME} = join('/', @script_name);
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS6ScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that IIS6 sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS6ScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS6ScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by IIS6.
  
  =head1 AUTHORS
  
  Florian Ragwitz
  
  =cut
PLACK_MIDDLEWARE_IIS6SCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/IIS7KeepAliveFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX';
  package Plack::Middleware::IIS7KeepAliveFix;
  
  use strict;
  use parent 'Plack::Middleware';
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
          # Fixes buffer being cut off on redirect when keep-alive is active
          my $res  = $self->app->($env);
  
          Plack::Util::response_cb($res, sub {
              my $res = shift;
              if ($res->[0] =~ m!^30[123]$! ) {
                  Plack::Util::header_remove($res->[1], 'Content-Length');
                  Plack::Util::header_remove($res->[1], 'Content-Type');
                 return sub{ my $chunk; return unless defined $chunk; return ''; };
              }
  
              return;
          });
  
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::IIS7KeepAliveFix - fixes buffer being cut off on redirect when keep-alive is active on IIS.
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "IIS7KeepAliveFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "IIS7KeepAliveFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes buffer being cut off on redirect when keep-alive is active on IIS7.
  
  =head1 AUTHORS
  
  KnowZeroX
  
  =cut
  
PLACK_MIDDLEWARE_IIS7KEEPALIVEFIX

$fatpacked{"Plack/Middleware/JSONP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  use Plack::Util::Accessor qw/callback_key/;
  
  sub prepare_app {
      my $self = shift;
      unless (defined $self->callback_key) {
          $self->callback_key('callback');
      }
  }
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2]) {
              my $h = Plack::Util::headers($res->[1]);
              my $callback_key = $self->callback_key;
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)$callback_key=([^&]+)/) {
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $body;
                      Plack::Util::foreach($res->[2], sub { $body .= $_[0] });
                      my $jsonp = "/**/$cb($body)";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 SYNOPSIS
  
      enable "JSONP", callback_key => 'jsonp';
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter. The
  name of the parameter can be set while enabling the middleware.
  
  This middleware only works with a non-streaming response, and doesn't
  touch the response otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/plack/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          die("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{REQUEST_METHOD}) {
          die('Missing env param: REQUEST_METHOD');
      }
      unless ($env->{REQUEST_METHOD} =~ /^[A-Z]+$/) {
          die("Invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{SCRIPT_NAME})) { # allows empty string
          die('Missing mandatory env param: SCRIPT_NAME');
      }
      if ($env->{SCRIPT_NAME} eq '/') {
          die('SCRIPT_NAME must not be /');
      }
      unless (defined($env->{PATH_INFO})) { # allows empty string
          die('Missing mandatory env param: PATH_INFO');
      }
      if ($env->{PATH_INFO} ne '' && $env->{PATH_INFO} !~ m!^/!) {
          die('PATH_INFO must begin with / ($env->{PATH_INFO})');
      }
      unless (defined($env->{SERVER_NAME})) {
          die('Missing mandatory env param: SERVER_NAME');
      }
      if ($env->{SERVER_NAME} eq '') {
          die('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{SERVER_PORT})) {
          die('Missing mandatory env param: SERVER_PORT');
      }
      if ($env->{SERVER_PORT} eq '') {
          die('SERVER_PORT must not be empty string');
      }
      if (defined($env->{SERVER_PROTOCOL}) and $env->{SERVER_PROTOCOL} !~ m{^HTTP/\d}) {
          die("Invalid SERVER_PROTOCOL: $env->{SERVER_PROTOCOL}");
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              die("Missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          die("psgi.version should be ArrayRef: $env->{'psgi.version'}");
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          die('psgi.version should contain 2 elements, not ', scalar(@{$env->{'psgi.version'}}));
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          die("psgi.url_scheme should be 'http' or 'https': ", $env->{'psgi.url_scheme'});
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  die("Missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          die('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          die('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub is_possibly_fh {
      my $fh = shift;
  
      ref $fh eq 'GLOB' &&
      *{$fh}{IO} &&
      *{$fh}{IO}->can('getline');
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      unless (ref($res) eq 'ARRAY' or ref($res) eq 'CODE') {
          die("Response should be array ref or code ref: $res");
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          die('Response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          die("Status code needs to be an integer greater than or equal to 100: $res->[0]");
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          die("Headers needs to be an array ref: $res->[1]");
      }
  
      my @copy = @{$res->[1]};
      unless (@copy % 2 == 0) {
          die('The number of response headers needs to be even, not odd(', scalar(@copy), ')');
      }
  
      while(my($key, $val) = splice(@copy, 0, 2)) {
          if (lc $key eq 'status') {
              die('Response headers MUST NOT contain a key named Status');
          }
          if ($key =~ /[:\r\n]|[-_]$/) {
              die("Response headers MUST NOT contain a key with : or newlines, or that end in - or _: $key");
          }
          unless ($key =~ /^[a-zA-Z][0-9a-zA-Z\-_]*$/) {
              die("Response headers MUST consist only of letters, digits, _ or - and MUST start with a letter: $key");
          }
          if ($val =~ /[\000-\037]/) {
              die("Response headers MUST NOT contain characters below octal \037: $val");
          }
          if (!defined $val) {
              die("Response headers MUST be a defined string");
          }
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              is_possibly_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          die("Body should be an array ref or filehandle: $res->[2]");
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep _has_wide_char($_), @{$res->[2]}) {
          die("Body must be bytes and should not contain wide characters (UTF-8 strings)");
      }
  
      return $res;
  }
  
  # NOTE: Some modules like HTML:: or XML:: could possibly generate
  # ASCII/Latin-1 strings with utf8 flags on. They're actually safe to
  # print, so there's no need to give warnings about it.
  sub _has_wide_char {
      my $str = shift;
      utf8::is_utf8($str) && $str =~ /[^\x00-\xff]/;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 DEBUGGING
  
  Because of how this middleware works, it may not be easy to debug Lint
  errors when you encounter one, unless you're writing a PSGI web server
  or a framework.
  
  For example, when you're an application developer (user of some
  framework) and see errors like:
  
    Body should be an array ref or filehandle at lib/Plack/Middleware/Lint.pm line XXXX
  
  there's no clue about which line of I<your application> produces that
  error.
  
  We're aware of the issue, and have a plan to spit out more helpful
  errors to diagnose the issue. But until then, currently there are some
  workarounds to make this easier. For now, the easiest one would be to
  enable L<Plack::Middleware::REPL> outside of the Lint middleware,
  like:
  
    plackup -e 'enable "REPL"; enable "Lint"' app.psgi
  
  so that the Lint errors are caught by the REPL shell, where you can
  inspect all the variables in the response.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a L<Plack::Middleware> component that allows you to use
  L<Log::Log4perl> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The C<log4perl> category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for L<Log::Log4perl> to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Log4perl>
  
  L<Plack::Middleware::LogDispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
  
          if ( ref $args->{message} && ref $args->{message} ne 'CODE' ) {
              $args->{message} .= q{};
          }
  
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a L<Plack::Middleware> component that allows you to use
  L<Log::Dispatch> to configure the logging object, C<psgix.logger>.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  L<Log::Dispatch> object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  L<Plack::Middleware::Log4perl>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/NullLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  use parent qw/Plack::Middleware/;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTION
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          } else {
              die $_; # rethrow
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 EXCEPTIONS
  
  This middleware passes through unknown exceptions to the outside
  middleware stack, so if you use this middleware with other exception
  handlers such as L<Plack::Middleware::StackTrace> or
  L<Plack::Middleware::HTTPExceptions>, be sure to wrap this so
  L<Plack::Middleware::Recursive> gets as inner as possible.
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
      my $header = $self->header_name || 'X-Runtime';
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], $header, $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  the application's response time (in seconds) in the I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          return unless $h->get('Content-Type');
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Config ();
  use Plack::Util::Accessor qw(level);
  use POSIX ();
  use Scalar::Util ();
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      my $env_ref = $env;
      Scalar::Util::weaken($env_ref);
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env_ref->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale;
      if ( $Config::config{d_setlocale} ) {
          $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'C');
      }
      my $out = POSIX::strftime(@_);
      if ( $Config::config{d_setlocale} ) {
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      };
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::LogErrors>, essentially the opposite of this module
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Scalar::Util qw( refaddr );
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if (try { require Devel::StackTrace::WithLexicals; Devel::StackTrace::WithLexicals->VERSION(0.08); 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my ($trace, %string_traces, %ref_traces);
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new(
              indent => 1, message => munge_error($_[0], [ caller ]),
              ignore_package => __PACKAGE__, no_refs => 1,
          );
          if (ref $_[0]) {
              $ref_traces{refaddr($_[0])} ||= $trace;
          }
          else {
              $string_traces{$_[0]} ||= $trace;
          }
          die @_;
      };
  
      my $caught;
      my $res = try {
          $self->app->($env);
      } catch {
          $caught = $_;
          [ 500, [ "Content-Type", "text/plain; charset=utf-8" ], [ no_trace_error(utf8_safe($caught)) ] ];
      };
  
      if ($caught) {
          # Try to find the correct trace for the caught exception
          my $caught_trace;
          if (ref $caught) {
              $caught_trace = $ref_traces{refaddr($caught)};
          }
          else {
              # This is not guaranteed to work if multiple exceptions with
              # the same message are thrown.
              $caught_trace = $string_traces{$caught};
          }
          $trace = $caught_trace if $caught_trace;
      }
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = $trace->as_string;
          my $html = $trace->as_html;
          $env->{'plack.stacktrace.text'} = $text;
          $env->{'plack.stacktrace.html'} = $html;
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub no_trace_error {
      my $msg = shift;
      chomp($msg);
  
      return <<EOF;
  The application raised the following error:
  
    $msg
  
  and the StackTrace middleware couldn't catch its stack trace, possibly because your application overrides \$SIG{__DIE__} by itself, preventing the middleware from working correctly. Remove the offending code or module that does it: known examples are CGI::Carp and Carp::Always.
  EOF
  }
  
  sub munge_error {
      my($err, $caller) = @_;
      return $err if ref $err;
  
      # Ugly hack to remove " at ... line ..." automatically appended by perl
      # If there's a proper way to do this, please let me know.
      $err =~ s/ at \Q$caller->[1]\E line $caller->[2]\.\n$//;
  
      return $err;
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarantee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware uses C<$SIG{__DIE__}> to intercept I<all> exceptions
  (run-time errors) happening in your application, even those that are caught.
  For each exception it builds a detailed stack trace.
  
  If the applications aborts by throwing an exception it will be caught and matched
  against the saved stack traces. If a match is found it will be displayed as a nice
  stack trace screen, if not then the exception will be reported without a stack trace.
  
  The stack trace is also stored in the environment as a plaintext and HTML under the key
  C<plack.stacktrace.text> and C<plack.stacktrace.html> respectively, so
  that middleware further up the stack can reference it.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head2 Stack Trace Module
  
  The L<Devel::StackTrace::WithLexicals> module will be used to capture the stack trace
  if the installed version is 0.08 or later. Otherwise L<Devel::StackTrace> is used.
  
  =head2 Performance
  
  Gathering the information for a stack trace via L<Devel::StackTrace> is slow,
  and L<Devel::StackTrace::WithLexicals> is significantly slower still.
  This is not usually a concern in development and when exceptions are rare.
  However, your application may include code that's throwing and catching exceptions
  that you're not aware of. Such code will run I<significantly> slower with this module.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding pass_through content_type );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      if ($res && not ($self->pass_through and $res->[0] == 404)) {
          return $res;
      }
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_, $env) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding, content_type => $self->content_type });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  This middleware allows your Plack-based application to serve static files.
  
  Note that if you are building an app using L<Plack::App::URLMap>, you should
  consider using L<Plack::App::File> to serve static files instead. This makes
  the overall routing of your application simpler to understand.
  
  With this middleware, if a static file exists for the requested path, it will
  be served. If it does not exist, by default this middleware returns a 404, but
  you can set the C<pass_through> option to change this behavior.
  
  If the requested document is not within the C<root> or the file is there but
  not readable, this middleware will return a 403 Forbidden response.
  
  The content type returned will be determined from the file extension by using
  L<Plack::MIME> or using C<content_type>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  The C<path> option specifies the URL pattern (regular expression) or a
  callback to match against requests. If the <path> option matches, the
  middleware looks in C<root> to find the static files to serve. The default
  value of C<root> is the current directory.
  
  This example configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched portion of the path,
  C</static/>, still appears in the locally mapped path under C<root>. If you
  don't want this to happen, you can use a callback to munge the path as you
  match it:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  The callback should operate on C<$_> and return a true or false value. Any
  changes it makes to C<$_> are used when looking for the static file in the
  C<root>.
  
  The configuration above serves C</static/foo.png> from
  C<static-files/foo.png>, not C<static-files/static/foo.png>. The callback
  specified in the C<path> option matches against C<$_> munges this value using
  C<s///>. The substitution operator returns the number of matches it made, so it
  will return true when the path matches C<^/static>.
  
  For more complex static handling in the C<path> callback, in addition
  to C<$_> being set the callback receives two arguments, C<PATH_INFO>
  (same as C<$_>) and C<$env>.
  
  If you want to map multiple static directories from different roots, simply
  add this middleware multiple times with different configuration options.
  
  =item pass_through
  
  When this option is set to a true value, then this middleware will never
  return a 404 if it cannot find a matching file. Instead, it will simply pass
  the request on to the application it is wrapping.
  
  =item content_type
  
  The C<content_type> option can be used to provide access to a different MIME 
  database than L<Plack::MIME>.
  L<Plack::MIME> works fast and good for a list of well known file endings, 
  but if you need a more accurate content based checking you can use modules
  like L<File::MimeInfo> or L<File::MMagic> for example.
  The callback should work on $_[0] which is the filename of the file.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/XFramework.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '1.0037';
  
  use HTTP::Headers::Fast;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Stream::Buffered;
  use URI;
  use URI::Escape ();
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub query_string{ $_[0]->env->{QUERY_STRING} }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = grep m/=/, split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= $self->_parse_query;
  }
  
  sub _parse_query {
      my $self = shift;
  
      my @query;
      my $query_string = $self->env->{QUERY_STRING};
      if (defined $query_string) {
          $query_string =~ s/\A[&;]+//;
          @query =
              map { s/\+/ /g; URI::Escape::uri_unescape($_) }
              map { /=/ ? split(/=/, $_, 2) : ($_ => '')}
              split(/[&;]+/, $query_string);
      }
  
      Hash::MultiValue->new(@query);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return '';
  
      $fh->seek(0, 0); # just in case middleware/apps read it without seeking back
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers::Fast->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      # We have to escape back PATH_INFO in case they include stuff like
      # ? or # so that the URI parser won't be tricked. However we should
      # preserve '/' since encoding them into %2f doesn't make sense.
      # This means when a request like /foo%2fbar comes in, we recognize
      # it as /foo/bar which is not ideal, but that's how the PSGI PATH_INFO
      # spec goes and we can't do anything about it. See PSGI::FAQ for details.
  
      # See RFC 3986 before modifying.
      my $path_escape_class = q{^/;:@&=A-Za-z0-9\$_.+!*'(),-};
  
      my $path = URI::Escape::uri_escape($self->env->{PATH_INFO} || '', $path_escape_class);
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      # HTTP::Body will create temporary files in case there was an
      # upload.  Those temporary files can be cleaned up by telling
      # HTTP::Body to do so. It will run the cleanup when the request
      # env is destroyed. That the object will not go out of scope by
      # the end of this sub we will store a reference here.
      $self->env->{'plack.request.http.body'} = $body;
      $body->cleanup(1);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Stream::Buffered->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      my %copy = %$upload;
      $copy{headers} = HTTP::Headers::Fast->new(%{$upload->{headers}});
      Plack::Request::Upload->new(%copy);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->parameters->{query};
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support PSGI (L<http://plackperl.org/#frameworks>),
  or see modules like L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 0.99. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve on your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item query_string
  
  Returns B<QUERY_STRING> in the environment. This is the undecoded
  query string in the request URI.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  If there are multiple cookies with the same name in the request, this
  method will ignore the duplicates and return only the first value. If
  that causes issues for you, you may have to use modules like
  CGI::Simple::Cookie to parse C<< $request->header('Cookies') >> by
  yourself.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). As with C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers::Fast> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is a L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters just in case you want the compatibility with
  CGI.pm objects.
  
  You are B<not recommended> to use this method since it is easy to
  misuse in a list context such as inside a hash constructor or method
  arguments. Use C<parameters> and Hash::MultiValue instead.
  
  Unlike CGI.pm, it does I<not> allow setting or modifying query
  parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values (i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads>) store the
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array references), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the C<get_all> method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and even call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->parameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  This is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume that the path is C</>.
  
  You will also want to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 0.99, many utility methods are removed or deprecated, and
  most methods are made read-only. These methods were deleted in version
  1.0001.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookies->{foo} ? $req->cookies->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookies->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '1.0037';
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Cookie::Baker ();
  use Scalar::Util ();
  use HTTP::Headers::Fast;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers::Fast->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers::Fast->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers::Fast->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      my $self = shift;
      return $self->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      my $headers = $self->headers;
      my @headers;
      $headers->scan(sub{
          my ($k,$v) = @_;
          $v =~ s/\015\012[\040|\011]+/chr(32)/ge; # replace LWS with a single SP
          $v =~ s/\015|\012//g; # remove CR and LF since the char is invalid here
          push @headers, $k, $v;
      });
  
      $self->_finalize_cookies(\@headers);
  
      return [
          $self->status,
          \@headers,
          $self->_body,
      ];
  }
  
  sub to_app {
      my $self = shift;
      return sub { $self->finalize };
  }
  
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q("")) && !$body->can('getline')) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my($self, $headers) = @_;
  
      foreach my $name ( keys %{ $self->cookies } ) {
          my $val = $self->cookies->{$name};
  
          my $cookie = Cookie::Baker::bake_cookie( $name, $val );
          push @$headers, 'Set-Cookie' => $cookie;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers::Fast->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers::Fast> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  Note that this method doesn't automatically set I<Content-Length> for
  the response. You have to set it manually if you want, with the
  C<content_length> method (see below).
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  Note that this method doesn't normalize the given URI string. Users of
  this module have to be responsible about properly encoding URI paths
  and parameters.
  
  =item location
  
  Gets and sets C<Location> header.
  
  Note that this method doesn't normalize the given URI string in the
  setter. See above in C<redirect> for details.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>,
  C<max-age>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =item finalize
  
    $res->finalize;
  
  Returns the status code, headers, and body of this response as a PSGI
  response array reference.
  
  =item to_app
  
    $app = $res->to_app;
  
  A helper shortcut for C<< sub { $res->finalize } >>.
  
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          default_middleware => 1,
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      my $parser = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case", "pass_through" ],
      );
  
      $parser->getoptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "access-log=s" => \$self->{access_log},
          "path=s"       => \$self->{path},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
          "default-middleware!" => \$self->{default_middleware},
      );
  
      my(@options, @argv);
      while (defined(my $arg = shift @ARGV)) {
          if ($arg =~ s/^--?//) {
              my @v = split '=', $arg, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $arg;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      if ($self->{default_middleware}) {
          $app = $self->apply_middleware($app, 'Lint');
          $app = $self->apply_middleware($app, 'StackTrace');
          if (!$ENV{GATEWAY_INTERFACE} and !$self->{access_log}) {
              $app = $self->apply_middleware($app, 'AccessLog');
          }
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      unless ($self->{options}) {
          $self->parse_options();
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      if ($self->{path}) {
          require Plack::App::URLMap;
          $app = build {
              my $urlmap = Plack::App::URLMap->new;
              $urlmap->mount($self->{path} => $_[0]);
              $urlmap->to_app;
          } $app;
      }
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      if ($self->{access_log}) {
          open my $logfh, ">>", $self->{access_log}
              or die "open($self->{access_log}): $!";
          $logfh->autoflush(1);
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { $logfh->print( @_ ) });
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly to the method, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    my $app = sub { ... };
  
    unless (caller) {
        require Plack::Runner;
        my $runner = Plack::Runner->new;
        $runner->parse_options(@ARGV);
        return $runner->run($app);
    }
  
    return $app;
  
  B<WARNING>: this section used to recommend C<if (__FILE__ eq $0)> but
  it's known to be broken since Plack 0.9971, since C<$0> is now
  I<always> set to the .psgi file path even when you run it from
  plackup.
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/TempBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  
  use parent 'Stream::Buffered';
  
  sub new {
      my $class = shift;
  
      if (defined $Plack::TempBuffer::MaxMemoryBufferSize) {
          warn "Setting \$Plack::TempBuffer::MaxMemoryBufferSize is deprecated. "
             . "You should set \$Stream::Buffered::MaxMemoryBufferSize instead.";
          $Stream::Buffered::MaxMemoryBufferSize = $Plack::TempBuffer::MaxMemoryBufferSize;
      }
  
      return $class->SUPER::new(@_);
  }
  
  1;
PLACK_TEMPBUFFER

$fatpacked{"Plack/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use Carp;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub create {
      my($class, $app, @args) = @_;
  
      my $subclass = "Plack::Test::$Impl";
      eval "require $subclass";
      die $@ if $@;
  
      no strict 'refs';
      if (defined &{"Plack::Test::$Impl\::test_psgi"}) {
          return \&{"Plack::Test::$Impl\::test_psgi"};
      }
  
      $subclass->new($app, @args);
  }
  
  sub test_psgi {
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      my %args = @_;
  
      my $app    = delete $args{app}; # Backward compat: some implementations don't need app
      my $client = delete $args{client} or Carp::croak "client test code needed";
  
      my $tester = Plack::Test->create($app, %args);
      return $tester->(@_) if ref $tester eq 'CODE'; # compatibility
  
      $client->(sub { $tester->request(@_) });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
    use HTTP::Request::Common;
  
    # Simple OO interface
    my $app = sub { return [ 200, [], [ "Hello "] ] };
    my $test = Plack::Test->create($app);
  
    my $res = $test->request(GET "/");
    is $res->content, "Hello";
  
    # traditional - named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb  = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
    # positional params (app, client)
    my $app = sub { return [ 200, [], [ "Hello "] ] };
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/");
        is $res->content, "Hello";
    };
  
  =head1 DESCRIPTION
  
  Plack::Test is a unified interface to test PSGI applications using
  L<HTTP::Request> and L<HTTP::Response> objects. It also allows you to run PSGI
  applications in various ways. The default backend is C<Plack::Test::MockHTTP>,
  but you may also use any L<Plack::Handler> implementation to run live HTTP
  requests against a web server.
  
  =head1 METHODS
  
  =over 4
  
  =item create
  
    $test = Plack::Test->create($app, %options);
  
  creates an instance of Plack::Test implementation class. C<$app> has
  to be a valid PSGI application code reference.
  
  =item request
  
    $res = $test->request($request);
  
  takes an HTTP::Request object, runs it through the PSGI application to
  test and returns an HTTP::Response object.
  
  =back
  
  =head1 FUNCTIONS
  
  Plack::Test also provides a functional interface that takes two
  callbacks, each of which represents PSGI application and HTTP client
  code that tests the application.
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, a
  callback that accepts an C<HTTP::Request> object and returns an
  C<HTTP::Response> object.
  
  Use L<HTTP::Request::Common> to import shortcuts for creating requests for
  C<GET>, C<POST>, C<DELETE>, and C<PUT> operations.
  
  For your convenience, the C<HTTP::Request> given to the callback automatically
  uses the HTTP protocol and the localhost (I<127.0.0.1> by default), so the
  following code just works:
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb  = shift;
        my $res = $cb->(GET "/hello");
    };
  
  Note that however, it is not a good idea to pass an arbitrary
  (i.e. user-input) string to C<GET> or even C<<
  HTTP::Request->new >> by assuming that it always represents a path,
  because:
  
    my $req = GET "//foo/bar";
  
  would represent a request for a URL that has no scheme, has a hostname
  I<foo> and a path I</bar>, instead of a path I<//foo/bar> which you
  might actually want.
  
  =back
  
  =head1 OPTIONS
  
  Specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, test your application with the C<HTTP::Server::ServerSimple>
  server backend with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=HTTP::Server::ServerSimple \
      prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub new {
      my($class, $app) = @_;
      bless { app => $app }, $class;
  }
  
  sub request {
      my($self, $req) = @_;
  
      $req->uri->scheme('http')    unless defined $req->uri->scheme;
      $req->uri->host('localhost') unless defined $req->uri->host;
      my $env = $req->to_psgi;
  
      my $res = try {
          HTTP::Response->from_psgi($self->{app}->($env));
      } catch {
          HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
      };
  
      $res->request($req);
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is a utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use Test::TCP;
  use Plack::Loader;
  use Plack::LWPish;
  
  sub new {
      my($class, $app, %args) = @_;
  
      my $server = Test::TCP->new(
          code => sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
              exit;
          },
      );
  
      bless { server => $server, %args }, $class;
  }
  
  sub port {
      my $self = shift;
      $self->{server}->port;
  }
  
  sub request {
      my($self, $req) = @_;
  
      my $ua = $self->{ua} || Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
  
      $req->uri->scheme('http');
      $req->uri->host($self->{host} || '127.0.0.1');
      $req->uri->port($self->port);
  
      return $ua->request($req);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is a utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  use Plack::LWPish;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  $ENV{PLACK_TEST_SCRIPT_NAME} = '';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'SCRIPT_NAME',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->content, "script_name=$ENV{PLACK_TEST_SCRIPT_NAME}";
          },
          sub {
              my $env = shift;
              return [ 200, ["Content-Type", "text/plain"], [ "script_name=$env->{SCRIPT_NAME}" ] ];
          },
      ],
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 2898;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 14750;
              is Digest::MD5::md5_hex($res->content), '70546a79c7abb9c497ca91730a0686e4';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  "SCRIPT_NAME:$ENV{PLACK_TEST_SCRIPT_NAME}",
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD SCRIPT_NAME PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO (outside of URI characters)',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo%E3%81%82");
              is $res->content, "/foo\x{e3}\x{81}\x{82}";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
              is $res->message, 'Internal Server Error';
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->message, 'Not Modified';
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, $ENV{PLACK_TEST_SCRIPT_NAME} . "/foo/bar%20baz%73?x=a";
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 2898;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'newlines',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is length($res->content), 7;
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Bar\nBaz" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->message, 'Not Found';
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
      [
          'handle Authorization header',
          sub {
              my $cb  = shift;
              SKIP: {
                  skip "Authorization header is unsupported under CGI", 4 if ($ENV{PLACK_TEST_HANDLER} || "") eq "CGI";
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      $req->push_header(Authorization => 'Basic XXXX');
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 1;
                      is $res->content, 'Basic XXXX';
                  };
  
                  {
                      my $req = HTTP::Request->new(
                          GET => "http://127.0.0.1/",
                      );
                      my $res = $cb->($req);
                      is $res->header('X-AUTHORIZATION'), 0;
                      is $res->content, 'no_auth';
                  };
              };
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-AUTHORIZATION' => exists($env->{HTTP_AUTHORIZATION}) ? 1 : 0 ],
                  [ $env->{HTTP_AUTHORIZATION} || 'no_auth' ],
              ];
          },
      ],
      [
          'repeated slashes',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1//foo///bar/baz");
              is $res->code, 200;
              is $res->message, 'OK';
              is $res->header('content_type'), 'text/plain';
              is $res->content, '//foo///bar/baz';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $ua = Plack::LWPish->new( no_proxy => [qw/127.0.0.1/] );
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->uri->path(($ENV{PLACK_TEST_SCRIPT_NAME}||"") . $req->uri->path);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
              exit(0); # for Test::TCP
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  Developers writing Plack applications should look at C<Plack::Test> for testing,
  as subclassing C<Plack::Handler> is for developing server implementations.
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  use File::Spec ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  # there does not seem to be a relevant RT or perldelta entry for this
  use constant _SPLICE_SAME_ARRAY_SEGFAULT => $] < '5.008007';
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      {
          no warnings 'uninitialized';
          return FALSE if -p $fh or -c _ or -b _;
      }
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      local $0 = $_file; # so FindBin etc. works
      local @ARGV = ();  # Some frameworks might try to parse @ARGV
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : File::Spec->rel2abs($stuff);
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      return () if not @$headers;
  
      my $i = 0;
  
      if (wantarray) {
          return map {
              $key eq lc $headers->[$i++] ? $headers->[$i++] : ++$i && ();
          } 1 .. @$headers/2;
      }
  
      while ($i < @$headers) {
          return $headers->[$i+1] if $key eq lc $headers->[$i];
          $i += 2;
      }
  
      ();
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      @$headers = ($key, $val), return if not @$headers;
  
      my ($i, $_key) = (0, lc $key);
  
      # locate and change existing header
      while ($i < @$headers) {
          $headers->[$i+1] = $val, last if $_key eq lc $headers->[$i];
          $i += 2;
      }
  
      if ($i > $#$headers) { # didn't find it?
          push @$headers, $key, $val;
          return;
      }
  
      $i += 2; # found and changed it; so, first, skip that pair
  
      return if $i > $#$headers; # anything left?
  
      # yes... so do the same thing as header_remove
      # but for the tail of the array only, starting at $i
  
      my $keep;
      my @keep = grep {
          $_ & 1 ? $keep : ($keep = $_key ne lc $headers->[$_]);
      } $i .. $#$headers;
  
      my $remainder = @$headers - $i;
      return if @keep == $remainder; # if we're not changing anything...
  
      splice @$headers, $i, $remainder, ( _SPLICE_SAME_ARRAY_SEGFAULT
          ? @{[ @$headers[@keep] ]} # force different source array
          :     @$headers[@keep]
      );
      ();
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $check;
      for (@$headers) {
          return 1 if ($check = not $check) and $key eq lc;
      }
  
      return !1;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      return if not @$headers;
  
      my $keep;
      my @keep = grep {
          $_ & 1 ? $keep : ($keep = $key ne lc $headers->[$_]);
      } 0 .. $#$headers;
  
      @$headers = @$headers[@keep] if @keep < @$headers;
      ();
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless \%args, 'Plack::Util::Prototype';
  }
  
  sub response_cb {
      my($res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub {
                                  my $chunk = $filter_cb->(undef);
                                  $writer->write($chunk) if defined $chunk;
                                  $writer->close;
                              };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      return $_[0]->{$_[1]} if Scalar::Util::blessed($_[0]);
      goto &UNIVERSAL::can;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  Note that this function doesn't validate (or "sanitize") the passed
  string, hence if you pass a user input to this function (which is an
  insecure thing to do in the first place) it might lead to unexpected
  behavior of loading files outside your C<@INC> path. If you want a
  generic module loading function, you should check out CPAN modules
  such as L<Module::Runtime>.
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 65536 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  Since version 1.0006, this function would not load PSGI files from
  include paths (C<@INC>) unless it looks like a class name that only
  consists of C<[A-Za-z0-9_:]>. For example:
  
    Plack::Util::load_psgi("app.psgi");          # ./app.psgi
    Plack::Util::load_psgi("/path/to/app.psgi"); # /path/to/app.psgi
    Plack::Util::load_psgi("MyApp::PSGI");       # MyApp/PSGI.pm from @INC
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose"
    $app = Plack::Util::load_psgi($psgi); # this would lead to 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. If you really want to do that, validate that
  a given file name contains dots (like C<foo.psgi>) and also turn it
  into a full path in your caller's code.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get($hdrs, 'content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =item encode_html
  
    my $encoded_string = Plack::Util::encode( $string );
  
  Entity encodes C<<>, C<< > >>, C<&>, C<"> and C<'> in the input string
  and returns it.
  
  =item response_cb
  
  See L<Plack::Middleware/RESPONSE CALLBACK> for details.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"RFXNames.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'RFXNAMES';
  package RFXNames;
  
  #based on SDK version 8.03A
  
  use constant {
  	pTypeRecXmitMessage => 0x02
  	sTypeReceiverLockError => 0x00
  	sTypeTransmitterResponse => 0x01
  
  	#undecoded => types
  	pTypeUndecoded => 0x03
  	sTypeUac => 0x00
  	sTypeUarc => 0x01
  	sTypeUati => 0x02
  	sTypeUhideki => 0x03
  	sTypeUlacrosse => 0x04
  	sTypeUad => 0x05
  	sTypeUmertik => 0x06
  	sTypeUoregon1 => 0x07
  	sTypeUoregon2 => 0x08
  	sTypeUoregon3 => 0x09
  	sTypeUproguard => 0x0A
  	sTypeUvisonic => 0x0B
  	sTypeUnec => 0x0C
  	sTypeUfs20 => 0x0D
  	sTypeUrsl => 0x0E
  	sTypeUblinds => 0x0F
  	sTypeUrubicson => 0x10
  	sTypeUae => 0x11
  	sTypeUfineoffset => 0x12
  	sTypeUrgb => 0x13
  	sTypeUrfy => 0x14
  	sTypeUselectplus => 0x15
  
  	#types => for => Lighting
  	pTypeLighting1 => 0x10
  	sTypeX10 => 0x0
  	sTypeARC => 0x1
  	sTypeAB400D => 0x2
  	sTypeWaveman => 0x3
  	sTypeEMW200 => 0x4
  	sTypeIMPULS => 0x5
  	sTypeRisingSun => 0x6
  	sTypePhilips => 0x7
  	sTypeEnergenie => 0x8
  	sTypeEnergenie5 => 0x9
  	sTypeGDR2 => 0x0A
  
  	light1_sOff => 0x0
  	light1_sOn => 0x1
  	light1_sDim => 0x2
  	light1_sBright => 0x3
  	light1_sAllOff => 0x5
  	light1_sAllOn => 0x6
  	light1_sChime => 0x7
  
  	pTypeLighting2 => 0x11
  	sTypeAC => 0x0
  	sTypeHEU => 0x1
  	sTypeANSLUT => 0x2
  	sTypeKambrook => 0x03
  
  	light2_sOff => 0x0
  	light2_sOn => 0x1
  	light2_sSetLevel => 0x2
  	light2_sGroupOff => 0x3
  	light2_sGroupOn => 0x4
  	light2_sSetGroupLevel => 0x5
  
  	pTypeLighting3 => 0x12
  	sTypeKoppla => 0x0
  	light3_sBright => 0x0
  	light3_sDim => 0x8
  	light3_sOn => 0x10
  	light3_sLevel1 => 0x11
  	light3_sLevel2 => 0x12
  	light3_sLevel3 => 0x13
  	light3_sLevel4 => 0x14
  	light3_sLevel5 => 0x15
  	light3_sLevel6 => 0x16
  	light3_sLevel7 => 0x17
  	light3_sLevel8 => 0x18
  	light3_sLevel9 => 0x19
  	light3_sOff => 0x1A
  	light3_sProgram => 0x1B
  
  	pTypeLighting4 => 0x13
  	sTypePT2262 => 0x0
  
  	pTypeLighting5 => 0x14
  	sTypeLightwaveRF => 0x0
  	sTypeEMW100 => 0x1
  	sTypeBBSB => 0x2
  	sTypeMDREMOTE => 0x03
  	sTypeRSL => 0x04
  	sTypeLivolo => 0x05
  	sTypeTRC02 => 0x06
  	sTypeAoke => 0x07
  	sTypeTRC02_2 => 0x08
  	sTypeEurodomest => 0x09
  	sTypeLivoloAppliance => 0x0A
  
  	light5_sOff => 0x0
  	light5_sOn => 0x1
  	light5_sGroupOff => 0x2
  	light5_sLearn => 0x2
  	light5_sGroupOn => 0x3
  	light5_sMood1 => 0x3
  	light5_sMood2 => 0x4
  	light5_sMood3 => 0x5
  	light5_sMood4 => 0x6
  	light5_sMood5 => 0x7
  	light5_sUnlock => 0xA
  	light5_sLock => 0xB
  	light5_sAllLock => 0xC
  	light5_sClose => 0xD
  	light5_sStop => 0xE
  	light5_sOpen => 0xF
  	light5_sSetLevel => 0x10
  	light5_sColourPalette => 0x11
  	light5_sColourTone => 0x12
  	light5_sColourCycle => 0x13
  	light5_sPower => 0x0
  	light5_sLight => 0x1
  	light5_sBright => 0x2
  	light5_sDim => 0x3
  	light5_s100 => 0x4
  	light5_s50 => 0x5
  	light5_s25 => 0x6
  	light5_sModePlus => 0x7
  	light5_sSpeedMin => 0x8
  	light5_sSpeedPlus => 0x9
  	light5_sModeMin => 0xA
  	light5_sLivoloAllOff => 0x00
  	light5_sLivoloGang1Toggle => 0x01
  	light5_sLivoloGang2Toggle => 0x02	#dim+ => for => dimmer
  	light5_sLivoloGang3Toggle => 0x03	#dim- => for => dimmer
  	light5_sLivoloGang4Toggle => 0x04
  	light5_sLivoloGang5Toggle => 0x05
  	light5_sLivoloGang6Toggle => 0x06
  	light5_sLivoloGang7Toggle => 0x07
  	light5_sLivoloGang8Toggle => 0x08
  	light5_sLivoloGang9Toggle => 0x09
  	light5_sLivoloGang10Toggle => 0x0A
  	light5_sRGBoff => 0x00
  	light5_sRGBon => 0x01
  	light5_sRGBbright => 0x02
  	light5_sRGBdim => 0x03
  	light5_sRGBcolorplus => 0x04
  	light5_sRGBcolormin => 0x05
  
  	pTypeLighting6 => 0x15
  	sTypeBlyss => 0x0
  	light6_sOn => 0x0
  	light6_sOff => 0x1
  	light6_sGroupOn => 0x2
  	light6_sGroupOff => 0x3
  
  	pTypeChime => 0x16
  	sTypeByronSX => 0x0
  	sTypeByronMP001 => 0x1
  	sTypeSelectPlus => 0x2
  	sTypeSelectPlus3 => 0x3
  	sTypeEnvivo => 0x4
  	chime_sound0 => 0x1
  	chime_sound1 => 0x3
  	chime_sound2 => 0x5
  	chime_sound3 => 0x9
  	chime_sound4 => 0xD
  	chime_sound5 => 0xE
  	chime_sound6 => 0x6
  	chime_sound7 => 0x2
  
  	pTypeFan => 0x17
  	sTypeSiemensSF01 => 0x0
  	fan_sTimer => 0x1
  	fan_sMin => 0x2
  	fan_sLearn => 0x3
  	fan_sPlus => 0x4
  	fan_sConfirm => 0x5
  	fan_sLight => 0x6
  
  	#types => for => Curtain
  	pTypeCurtain => 0x18
  	sTypeHarrison => 0x0
  	curtain_sOpen => 0x0
  	curtain_sClose => 0x1
  	curtain_sStop => 0x2
  	curtain_sProgram => 0x3
  
  	#types => for => Blinds
  	pTypeBlinds => 0x19
  	sTypeBlindsT0 => 0x0	#RollerTrol, => Hasta => new
  	sTypeBlindsT1 => 0x1	#Hasta => old
  	sTypeBlindsT2 => 0x2	#A-OK => RF01
  	sTypeBlindsT3 => 0x3	#A-OK => AC114
  	sTypeBlindsT4 => 0x4	#RAEX => YR1326
  	sTypeBlindsT5 => 0x5	#Media => Mount
  	sTypeBlindsT6 => 0x6	#DC106, => YOOHA, => Rohrmotor24 => RMF
  	sTypeBlindsT7 => 0x7	#Forest
  	sTypeBlindsT8 => 0x8	#Chamberlain => CS4330CN
  	sTypeBlindsT9 => 0x9	#Sunpery
  	sTypeBlindsT10 => 0xA	#Dolat => DLM-1
  
  	blinds_sOpen => 0x0
  	blinds_sClose => 0x1
  	blinds_sStop => 0x2
  	blinds_sConfirm => 0x3
  	blinds_sLimit => 0x4
  	blinds_slowerLimit => 0x5
  	blinds_sDeleteLimits => 0x6
  	blinds_sChangeDirection => 0x7
  	blinds_sLeft => 0x8
  	blinds_sRight => 0x9
  	blinds_s9ChangeDirection => 0x6
  	blinds_s9ImA => = => 0x7
  	blinds_s9ImCenter => = => 0x8
  	blinds_s9ImB => = => 0x9
  	blinds_s9EraseCurrentCh => = => 0xA
  	blinds_s9EraseAllCh => = => 0xB
  	blinds_s10LearnMaster => = => 0x4
  	blinds_s10EraseCurrentCh => = => 0x5
  	blinds_s10ChangeDirection => = => 0x6
  
  	#types => for => RFY
  	pTypeRFY => 0x1A
  	sTypeRFY => 0x0	#RFY
  	sTypeRFYext => 0x1	#RFY => extended
  	rfy_sStop => 0x0
  	rfy_sUp => 0x1
  	rfy_sUpStop => 0x2
  	rfy_sDown => 0x3
  	rfy_sDownStop => 0x4
  	rfy_sUpDown => 0x5
  	rfy_sListRemotes => 0x6
  	rfy_sProgram => 0x7
  	rfy_s2SecProgram => 0x8
  	rfy_s7SecProgram => 0x9
  	rfy_s2SecStop => 0xA
  	rfy_s5SecStop => 0xB
  	rfy_s5SecUpDown => 0xC
  	rfy_sEraseThis => 0xD
  	rfy_sEraseAll => 0xE
  	rfy_s05SecUp => 0xF
  	rfy_s05SecDown => 0x10
  	rfy_s2SecUp => 0x11
  	rfy_s2SecDown => 0x12
  	rfy_sEnableSunWind => 0x13
  	rfy_sDisableSun => 0x14
  
  	#types => for => Security1
  	pTypeSecurity1 => 0x20
  	sTypeSecX10 => 0x0				#X10 => security
  	sTypeSecX10M => 0x1			#X10 => security => motion
  	sTypeSecX10R => 0x2			#X10 => security => remote
  	sTypeKD101 => 0x3				#KD101 => smoke => detector
  	sTypePowercodeSensor => 0x04	#Visonic => PowerCode => sensor => - => primary => contact
  	sTypePowercodeMotion => 0x05	#Visonic => PowerCode => motion
  	sTypeCodesecure => 0x06		#Visonic => CodeSecure
  	sTypePowercodeAux => 0x07		#Visonic => PowerCode => sensor => - => auxiliary => contact
  	sTypeMeiantech => 0x8			#Meiantech
  	sTypeSA30 => 0x9				#SA30 => smoke => detector
  
  	#status => security
  	sStatusNormal => 0x0
  	sStatusNormalDelayed => 0x1
  	sStatusAlarm => 0x2
  	sStatusAlarmDelayed => 0x3
  	sStatusMotion => 0x4
  	sStatusNoMotion => 0x5
  	sStatusPanic => 0x6
  	sStatusPanicOff => 0x7
  	sStatusIRbeam => 0x8
  	sStatusArmAway => 0x9
  	sStatusArmAwayDelayed => 0xA
  	sStatusArmHome => 0xB
  	sStatusArmHomeDelayed => 0xC
  	sStatusDisarm => 0xD
  	sStatusLightOff => 0x10
  	sStatusLightOn => 0x11
  	sStatusLight2Off => 0x12
  	sStatusLight2On => 0x13
  	sStatusDark => 0x14
  	sStatusLight => 0x15
  	sStatusBatLow => 0x16
  	sStatusPairKD101 => 0x17
  	sStatusNormalTamper => 0x80
  	sStatusNormalDelayedTamper => 0x81
  	sStatusAlarmTamper => 0x82
  	sStatusAlarmDelayedTamper => 0x83
  	sStatusMotionTamper => 0x84
  	sStatusNoMotionTamper => 0x85
  
  	#types => for => Security2
  	pTypeSecurity2 => 0x21
  	sTypeSec2Classic => 0x0
  
  	#types => for => Camera
  	pTypeCamera => 0x28
  	sTypeNinja => 0x0		#X10 => Ninja/Robocam
  	camera_sLeft => 0x0
  	camera_sRight => 0x1
  	camera_sUp => 0x2
  	camera_sDown => 0x3
  	camera_sPosition1 => 0x4
  	camera_sProgramPosition1 => 0x5
  	camera_sPosition2 => 0x6
  	camera_sProgramPosition2 => 0x7
  	camera_sPosition3 => 8
  	camera_sProgramPosition3 => 0x9
  	camera_sPosition4 => 0xA
  	camera_sProgramPosition4 => 0xB
  	camera_sCenter => 0xC
  	camera_sProgramCenterPosition => 0xD
  	camera_sSweep => 0xE
  	camera_sProgramSweep => 0xF
  
  	#types => for => Remotes
  	pTypeRemote => 0x30
  	sTypeATI => 0x0		#ATI => Remote => Wonder
  	sTypeATIplus => 0x1	#ATI => Remote => Wonder => Plus
  	sTypeMedion => 0x2		#Medion => Remote
  	sTypePCremote => 0x3	#PC => Remote
  	sTypeATIrw2 => 0x4		#ATI => Remote => Wonder => II
  
  	#types => for => Thermostat
  	pTypeThermostat1 => 0x40
  	sTypeDigimax => 0x0		#Digimax
  	sTypeDigimaxShort => 0x1	#Digimax => with => short => format
  	thermostat1_sNoStatus => 0x0
  	thermostat1_sDemand => 0x1
  	thermostat1_sNoDemand => 0x2
  	thermostat1_sInitializing => 0x3
  
  	pTypeThermostat2 => 0x41
  	sTypeHE105 => 0x0
  	sTypeRTS10 => 0x1
  	thermostat2_sOff => 0x0
  	thermostat2_sOn => 0x1
  	thermostat2_sProgram => 0x2
  
  	pTypeThermostat3 => 0x42
  	sTypeMertikG6RH4T1 => 0x0	#Mertik => G6R-H4T1
  	sTypeMertikG6RH4TB => 0x1	#Mertik => G6R-H4TB
  	sTypeMertikG6RH4TD => 0x2	#Mertik => G6R-H4TD
  	sTypeMertikG6RH4S => 0x3	#Mertik => G6R-H4S
  	thermostat3_sOff => 0x0
  	thermostat3_sOn => 0x1
  	thermostat3_sUp => 0x2
  	thermostat3_sDown => 0x3
  	thermostat3_sRunUp => 0x4
  	thermostat3_Off2nd => 0x4
  	thermostat3_sRunDown => 0x5
  	thermostat3_On2nd => 0x5
  	thermostat3_sStop => 0x6
  
  	#types => for => Radiator => valve
  	pTypeRadiator1 => 0x48
  	sTypeSmartwares => 0x0	#Homewizard => smartwares
  
  	Radiator1_sNight => 0x0
  	Radiator1_sDay => 0x1
  	Radiator1_sSetTemp => 0x2
  
  	#types => for => BBQ => temperature
  	pTypeBBQ => 0x4E
  	sTypeBBQ1 => 0x1 =>  => #Maverick => ET-732
  
  	#types => for => temperature+rain
  	pTypeTEMP_RAIN => 0x4F
  	sTypeTR1 => 0x1 =>  => #WS1200
  
  	#types => for => temperature
  	pTypeTEMP => 0x50
  	sTypeTEMP1 => 0x1 =>  => #THR128/138,THC138
  	sTypeTEMP2 => 0x2 =>  => #THC238/268,THN132,THWR288,THRN122,THN122,AW129/131
  	sTypeTEMP3 => 0x3 =>  => #THWR800
  	sTypeTEMP4 => 0x4	#RTHN318
  	sTypeTEMP5 => 0x5 =>  => #LaCrosse => TX3
  	sTypeTEMP6 => 0x6 =>  => #TS15C
  	sTypeTEMP7 => 0x7 =>  => #Viking => 02811,TSS330
  	sTypeTEMP8 => 0x8 =>  => #LaCrosse => WS2300
  	sTypeTEMP9 => 0x9 =>  => #RUBiCSON
  	sTypeTEMP10 => 0xA =>  => #TFA => 30.3133
  	sTypeTEMP11 => 0xB =>  => #WT0122
  
  	#types => for => humidity
  	pTypeHUM => 0x51
  	sTypeHUM1 => 0x1 =>  => #LaCrosse => TX3
  	sTypeHUM2 => 0x2 =>  => #LaCrosse => WS2300
  
  	#status => types => for => humidity
  	humstat_normal => 0x0
  	humstat_comfort => 0x1
  	humstat_dry => 0x2
  	humstat_wet => 0x3
  
  	#types => for => temperature+humidity
  	pTypeTEMP_HUM => 0x52
  	sTypeTH1 => 0x1 =>  => #THGN122/123,THGN132,THGR122/228/238/268
  	sTypeTH2 => 0x2 =>  => #THGR810,THGN800
  	sTypeTH3 => 0x3 =>  => #RTGR328
  	sTypeTH4 => 0x4 =>  => #THGR328
  	sTypeTH5 => 0x5 =>  => #WTGR800
  	sTypeTH6 => 0x6 =>  => #THGR918,THGRN228,THGN500
  	sTypeTH7 => 0x7 =>  => #TFA => TS34C, => Cresta
  	sTypeTH8 => 0x8 =>  => #WT450H
  	sTypeTH9 => 0x9 =>  => #Viking => 02035,02038 => (02035 => has => no => humidity), => TSS320
  	sTypeTH10 => 0xA =>  =>  => #Rubicson
  	sTypeTH11 => 0xB =>  =>  => #EW109
  	sTypeTH12 => 0xC =>  =>  => #Imagintronix
  	sTypeTH13 => 0xD =>  =>  => #Alecto => WS1700 => and => compatibles
  	sTypeTH14 => 0xE =>  =>  => #Alecto
  
  	#types => for => barometric
  	pTypeBARO => 0x53
  
  	#types => for => temperature+humidity+baro
  	pTypeTEMP_HUM_BARO => 0x54
  	sTypeTHB1 => 0x1 =>  =>  => #BTHR918,BTHGN129
  	sTypeTHB2 => 0x2 =>  =>  => #BTHR918N,BTHR968
  	baroForecastNoInfo => 0x00
  	baroForecastSunny => 0x01
  	baroForecastPartlyCloudy => 0x02
  	baroForecastCloudy => 0x03
  	baroForecastRain => 0x04
  
  	#types => for => rain
  	pTypeRAIN => 0x55
  	sTypeRAIN1 => 0x1 =>  =>  => #RGR126/682/918
  	sTypeRAIN2 => 0x2 =>  =>  => #PCR800
  	sTypeRAIN3 => 0x3 =>  =>  => #TFA
  	sTypeRAIN4 => 0x4 =>  =>  => #UPM
  	sTypeRAIN5 => 0x5 =>  =>  => #WS2300
  	sTypeRAIN6 => 0x6 =>  =>  => #TX5
  	sTypeRAIN7 => 0x7 =>  =>  => #Alecto
  
  	#types => for => wind
  	pTypeWIND => 0x56
  	sTypeWIND1 => 0x1 =>  =>  => #WTGR800
  	sTypeWIND2 => 0x2 =>  =>  => #WGR800
  	sTypeWIND3 => 0x3 =>  =>  => #STR918,WGR918
  	sTypeWIND4 => 0x4 =>  =>  => #TFA
  	sTypeWIND5 => 0x5 =>  =>  => #UPM
  	sTypeWIND6 => 0x6 =>  =>  => #WS2300
  	sTypeWIND7 => 0x7 =>  =>  => #Alecto => WS4500
  
  	#types => for => uv
  	pTypeUV => 0x57
  	sTypeUV1 => 0x1 =>  =>  => #UVN128,UV138
  	sTypeUV2 => 0x2 =>  =>  => #UVN800
  	sTypeUV3 => 0x3 =>  =>  => #TFA
  
  	#types => for => date => & => time
  	pTypeDT => 0x58
  	sTypeDT1 => 0x1 =>  =>  => #RTGR328N
  
  	#types => for => current
  	pTypeCURRENT => 0x59
  	sTypeELEC1 => 0x1 =>  =>  => #CM113,Electrisave
  
  	#types => for => energy
  	pTypeENERGY => 0x5A
  	sTypeELEC2 => 0x1 =>  =>  => #CM119/160
  	sTypeELEC3 => 0x2 =>  =>  => #CM180
  
  	#types => for => current-energy
  	pTypeCURRENTENERGY => 0x5B
  	sTypeELEC4 => 0x1 =>  =>  => #CM180i
  
  	#types => for => power
  	pTypePOWER => 0x5C
  	sTypeELEC5 => 0x1 =>  =>  => #revolt
  
  	#types => for => weight => scales
  	pTypeWEIGHT => 0x5D
  	sTypeWEIGHT1 => 0x1 =>  =>  => #BWR102
  	sTypeWEIGHT2 => 0x2 =>  =>  => #GR101
  
  	#types => for => gas
  	pTypeGAS => 0x5E
  
  	#types => for => water
  	pTypeWATER => 0x5F
  
  	#RFXSensor
  	pTypeRFXSensor => 0x70
  	sTypeRFXSensorTemp => 0x0
  	sTypeRFXSensorAD => 0x1
  	sTypeRFXSensorVolt => 0x2
  	sTypeRFXSensorMessage => 0x3
  
  	#RFXMeter
  	pTypeRFXMeter => 0x71
  	sTypeRFXMeterCount => 0x0
  	sTypeRFXMeterInterval => 0x1
  	sTypeRFXMeterCalib => 0x2
  	sTypeRFXMeterAddr => 0x3
  	sTypeRFXMeterCounterReset => 0x4
  	sTypeRFXMeterCounterSet => 0xB
  	sTypeRFXMeterSetInterval => 0xC
  	sTypeRFXMeterSetCalib => 0xD
  	sTypeRFXMeterSetAddr => 0xE
  	sTypeRFXMeterIdent => 0xF
  
  	#FS20
  	pTypeFS20 => 0x72
  	sTypeFS20 => 0x0
  	sTypeFHT8V => 0x1
  	sTypeFHT80 => 0x2
  };
  
  my %pType= {
  0	=>	{ pTypeInterfaceControl, "Interface Control", "unknown" },
  1	=>	{ pTypeInterfaceMessage, "Interface Message", "unknown" },
  2	=>	{ pTypeRecXmitMessage, "Receiver/Transmitter Message", "unknown" },
  3	=>	{ pTypeUndecoded, "Undecoded RF Message", "unknown" },
  4	=>	{ pTypeLighting1, "Lighting 1" , "lightbulb", },
  5	=>	{ pTypeLighting2, "Lighting 2" , "lightbulb", },
  6	=>	{ pTypeLighting3, "Lighting 3" , "lightbulb", },
  7	=>	{ pTypeLighting4, "Lighting 4" , "lightbulb", },
  8	=>	{ pTypeLighting5, "Lighting 5" , "lightbulb", },
  9	=>	{ pTypeLighting6, "Lighting 6" , "lightbulb", },
  10	=>	{ pTypeLimitlessLights, "Lighting Limitless/Applamp" , "lightbulb" },
  11	=>	{ pTypeCurtain, "Curtain" , "blinds" },
  12	=>	{ pTypeBlinds, "Blinds" , "blinds" },
  13	=>	{ pTypeSecurity1, "Security", "security" },
  14	=>	{ pTypeSecurity2, "Security", "security" },
  15	=>	{ pTypeCamera, "Camera", "unknown" },
  16	=>	{ pTypeRemote, "Remote & IR" , "unknown" },
  17	=>	{ pTypeThermostat1, "Thermostat 1" , "temperature" },
  18	=>	{ pTypeThermostat2, "Thermostat 2" , "temperature" },
  19	=>	{ pTypeThermostat3, "Thermostat 3" , "temperature" },
  20	=>	{ pTypeRadiator1, "Radiator 1", "temperature" },
  21	=>	{ pTypeTEMP, "Temp", "temperature" },
  22	=>	{ pTypeHUM, "Humidity" , "temperature" },
  23	=>	{ pTypeTEMP_HUM, "Temp + Humidity" , "temperature" },
  24	=>	{ pTypeBARO, "Barometric" , "temperature" },
  25	=>	{ pTypeTEMP_HUM_BARO, "Temp + Humidity + Baro" , "temperature" },
  26	=>	{ pTypeRAIN, "Rain" , "rain" },
  27	=>	{ pTypeWIND, "Wind" , "wind" },
  28	=>	{ pTypeUV, "UV" , "uv" },
  29	=>	{ pTypeDT, "Date/Time" , "unknown" },
  30	=>	{ pTypeCURRENT, "Current" , "current" },
  31	=>	{ pTypeENERGY, "Energy" , "current" },
  32	=>	{ pTypeCURRENTENERGY, "Current/Energy" , "current" },
  33	=>	{ pTypeGAS, "Gas" , "counter" },
  34	=>	{ pTypeWATER, "Water" , "counter" },
  35	=>	{ pTypeWEIGHT, "Weight" , "scale" },
  36	=>	{ pTypeRFXSensor, "RFXSensor" , "unknown" },
  37	=>	{ pTypeRFXMeter, "RFXMeter" , "counter" },
  38	=>	{ pTypeP1Power, "P1 Smart Meter" , "counter" },
  39	=>	{ pTypeP1Gas, "P1 Smart Meter" , "counter" },
  40	=>	{ pTypeYouLess, "YouLess Meter", "counter" },
  41	=>	{ pTypeFS20, "FS20" , "unknown" },
  42	=>	{ pTypeRego6XXTemp, "Temp" , "temperature" },
  43	=>	{ pTypeRego6XXValue, "Value" , "utility" },
  44	=>	{ pTypeAirQuality, "Air Quality" , "air" },
  45	=>	{ pTypeUsage, "Usage" , "current" },
  46	=>	{ pTypeTEMP_BARO, "Temp + Baro" , "temperature" },
  47	=>	{ pTypeLux, "Lux" , "lux" },
  48	=>	{ pTypeGeneral, "General" , "General" },
  49	=>	{ pTypeThermostat, "Thermostat" , "thermostat" },
  50	=>	{ pTypeTEMP_RAIN, "Temp + Rain" , "Temp + Rain" },
  51	=>	{ pTypeChime, "Chime" , "doorbell" },
  52	=>	{ pTypeBBQ, "BBQ Meter", "bbq" },
  53	=>	{ pTypePOWER, "Current/Energy" , "current" },
  54	=>	{ pTypeRFY, "RFY" , "blinds" },
  55	=>	{ pTypeEvohome, "Heating" , "evohome" },
  56	=>	{ pTypeEvohomeZone, "Heating" , "evohome" },
  57	=>	{ pTypeEvohomeWater, "Heating" , "evohome" },
  58	=>	{ pTypeEvohomeRelay, "Heating" , "evohome" },
  59	=>	{ pTypeGeneralSwitch, "Light/Switch", "lightbulb" },
  
  };
  
  my %sType = {
   sTypeTEMP1	=>	pTypeTEMP		,
   sTypeTEMP2	=>	pTypeTEMP		,
   sTypeTEMP3	=>	pTypeTEMP		,
   sTypeTEMP4	=>	pTypeTEMP		,
   sTypeTEMP5	=>	pTypeTEMP		,
   sTypeTEMP6	=>	pTypeTEMP		,
   sTypeTEMP7	=>	pTypeTEMP		,
   sTypeTEMP8	=>	pTypeTEMP		,
   sTypeTEMP9	=>	pTypeTEMP		,
   sTypeTEMP10	=>	pTypeTEMP		,
   sTypeTEMP11	=>	pTypeTEMP		,
   sTypeTEMP_SYSTEM	=>	pTypeTEMP		,
   sTypeHUM1	=>	pTypeHUM		,
   sTypeHUM2	=>	pTypeHUM		,
   sTypeTH1	=>	pTypeTEMP_HUM		,
   sTypeTH2	=>	pTypeTEMP_HUM		,
   sTypeTH3	=>	pTypeTEMP_HUM		,
   sTypeTH4	=>	pTypeTEMP_HUM		,
   sTypeTH5	=>	pTypeTEMP_HUM		,
   sTypeTH6	=>	pTypeTEMP_HUM		,
   sTypeTH7	=>	pTypeTEMP_HUM		,
   sTypeTH8	=>	pTypeTEMP_HUM		,
   sTypeTH9	=>	pTypeTEMP_HUM		,
   sTypeTH10	=>	pTypeTEMP_HUM		,
   sTypeTH11	=>	pTypeTEMP_HUM		,
   sTypeTH12	=>	pTypeTEMP_HUM		,
   sTypeTH_LC_TC	=>	pTypeTEMP_HUM		,
   sTypeTHB1	=>	pTypeTEMP_HUM_BARO		,
   sTypeTHB2	=>	pTypeTEMP_HUM_BARO		,
   sTypeTHBFloat	=>	pTypeTEMP_HUM_BARO		,
   sTypeRAIN1	=>	pTypeRAIN		,
   sTypeRAIN2	=>	pTypeRAIN		,
   sTypeRAIN3	=>	pTypeRAIN		,
   sTypeRAIN4	=>	pTypeRAIN		,
   sTypeRAIN5	=>	pTypeRAIN		,
   sTypeRAIN6	=>	pTypeRAIN		,
   sTypeRAINWU	=>	pTypeRAIN		,
   sTypeWIND1	=>	pTypeWIND		,
   sTypeWIND2	=>	pTypeWIND		,
   sTypeWIND3	=>	pTypeWIND		,
   sTypeWIND4	=>	pTypeWIND		,
   sTypeWIND5	=>	pTypeWIND		,
   sTypeWIND6	=>	pTypeWIND		,
   sTypeWIND7	=>	pTypeWIND		,
   sTypeWINDNoTemp	=>	pTypeWIND		,
   sTypeUV1	=>	pTypeUV		,
   sTypeUV2	=>	pTypeUV		,
   sTypeUV3	=>	pTypeUV		,
   sTypeX10	=>	pTypeLighting1		,
   sTypeARC	=>	pTypeLighting1		,
   sTypeAB400D	=>	pTypeLighting1		,
   sTypeWaveman	=>	pTypeLighting1		,
   sTypeEMW200	=>	pTypeLighting1		,
   sTypeIMPULS	=>	pTypeLighting1		,
   sTypeRisingSun	=>	pTypeLighting1		,
   sTypePhilips	=>	pTypeLighting1		,
   sTypeEnergenie	=>	pTypeLighting1		,
   sTypeEnergenie5	=>	pTypeLighting1		,
   sTypeGDR2	=>	pTypeLighting1		,
   sTypeAC	=>	pTypeLighting2		,
   sTypeHEU	=>	pTypeLighting2		,
   sTypeANSLUT	=>	pTypeLighting2		,
   sTypeZWaveSwitch	=>	pTypeLighting2		,
   sTypeKoppla	=>	pTypeLighting3		,
   sTypePT2262	=>	pTypeLighting4		,
   sTypeLightwaveRF	=>	pTypeLighting5		,
   sTypeEMW100	=>	pTypeLighting5		,
   sTypeBBSB	=>	pTypeLighting5		,
   sTypeMDREMOTE	=>	pTypeLighting5		,
   sTypeRSL	=>	pTypeLighting5		,
   sTypeLivolo	=>	pTypeLighting5		,
   sTypeTRC02	=>	pTypeLighting5		,
   sTypeTRC02_2	=>	pTypeLighting5		,
   sTypeAoke	=>	pTypeLighting5		,
   sTypeEurodomest	=>	pTypeLighting5		,
   sTypeLivoloAppliance	=>	pTypeLighting5		,
   sTypeBlyss	=>	pTypeLighting6		,
   sTypeHarrison	=>	pTypeCurtain		,
   sTypeBlindsT0	=>	pTypeBlinds		,
   sTypeBlindsT1	=>	pTypeBlinds		,
   sTypeBlindsT2	=>	pTypeBlinds		,
   sTypeBlindsT3	=>	pTypeBlinds		,
   sTypeBlindsT4	=>	pTypeBlinds		,
   sTypeBlindsT5	=>	pTypeBlinds		,
   sTypeBlindsT6	=>	pTypeBlinds		,
   sTypeBlindsT7	=>	pTypeBlinds		,
   sTypeBlindsT8	=>	pTypeBlinds		,
   sTypeBlindsT9	=>	pTypeBlinds		,
   sTypeBlindsT10	=>	pTypeBlinds		,
   sTypeSecX10	=>	pTypeSecurity1		,
   sTypeSecX10M	=>	pTypeSecurity1		,
   sTypeSecX10R	=>	pTypeSecurity1		,
   sTypeKD101	=>	pTypeSecurity1		,
   sTypePowercodeSensor	=>	pTypeSecurity1		,
   sTypePowercodeMotion	=>	pTypeSecurity1		,
   sTypeCodesecure	=>	pTypeSecurity1		,
   sTypePowercodeAux	=>	pTypeSecurity1		,
   sTypeMeiantech	=>	pTypeSecurity1		,
   sTypeSA30	=>	pTypeSecurity1		,
   sTypeDomoticzSecurity	=>	pTypeSecurity1		,
   sTypeSec2Classic	=>	pTypeSecurity2		,
   sTypeNinja	=>	pTypeCamera		,
   sTypeATI	=>	pTypeRemote		,
   sTypeATIplus	=>	pTypeRemote		,
   sTypeMedion	=>	pTypeRemote		,
   sTypePCremote	=>	pTypeRemote		,
   sTypeATIrw2	=>	pTypeRemote		,
   sTypeDigimax	=>	pTypeThermostat1		,
   sTypeDigimaxShort	=>	pTypeThermostat1		,
   sTypeHE105	=>	pTypeThermostat2		,
   sTypeRTS10	=>	pTypeThermostat2		,
   sTypeMertikG6RH4T1	=>	pTypeThermostat3		,
   sTypeMertikG6RH4TB	=>	pTypeThermostat3		,
   sTypeMertikG6RH4TD	=>	pTypeThermostat3		,
   sTypeMertikG6RH4S	=>	pTypeThermostat3		,
   sTypeSmartwares	=>	pTypeRadiator1		,
   sTypeSmartwaresSwitchRadiator	=>	pTypeRadiator1		,
   sTypeDT1	=>	pTypeDT		,
   sTypeELEC1	=>	pTypeCURRENT		,
   sTypeELEC2	=>	pTypeENERGY		,
   sTypeELEC3	=>	pTypeENERGY		,
   sTypeZWaveUsage	=>	pTypeENERGY		,
   sTypeELEC4	=>	pTypeCURRENTENERGY		,
   sTypeWEIGHT1	=>	pTypeWEIGHT		,
   sTypeWEIGHT2	=>	pTypeWEIGHT		,
   sTypeRFXSensorTemp	=>	pTypeRFXSensor		,
   sTypeRFXSensorAD	=>	pTypeRFXSensor		,
   sTypeRFXSensorVolt	=>	pTypeRFXSensor		,
   sTypeRFXMeterCount	=>	pTypeRFXMeter		,
   sTypeP1Power	=>	pTypeP1Power		,
   sTypeP1Gas	=>	pTypeP1Gas		,
   sTypeYouLess	=>	pTypeYouLess		,
   sTypeRego6XXTemp	=>	pTypeRego6XXTemp		,
   sTypeRego6XXStatus	=>	pTypeRego6XXValue		,
   sTypeRego6XXCounter	=>	pTypeRego6XXValue		,
   sTypeVoltcraft	=>	pTypeAirQuality		,
   sTypeElectric	=>	pTypeUsage		,
   sTypeBMP085	=>	pTypeTEMP_BARO		,
   sTypeLux	=>	pTypeLux		,
   sTypeVisibility	=>	pTypeGeneral		,
   sTypeSolarRadiation	=>	pTypeGeneral		,
   sTypeSoilMoisture	=>	pTypeGeneral		,
   sTypeLeafWetness	=>	pTypeGeneral		,
   sTypeSystemTemp	=>	pTypeGeneral		,
   sTypePercentage	=>	pTypeGeneral		,
   sTypeFan	=>	pTypeGeneral		,
   sTypeVoltage	=>	pTypeGeneral		,
   sTypeCurrent	=>	pTypeGeneral		,
   sTypePressure	=>	pTypeGeneral		,
   sTypeBaro	=>	pTypeGeneral		,
   sTypeSetPoint	=>	pTypeGeneral		,
   sTypeTemperature	=>	pTypeGeneral		,
   sTypeZWaveClock	=>	pTypeGeneral		,
   sTypeTextStatus	=>	pTypeGeneral		,
   sTypeZWaveThermostatMode	=>	pTypeGeneral		,
   sTypeZWaveThermostatFanMode	=>	pTypeGeneral		,
   sTypeAlert	=>	pTypeGeneral		,
   sTypeSoundLevel	=>	pTypeGeneral		,
   sTypeDistance	=>	pTypeGeneral		,
   sTypeThermSetpoint	=>	pTypeThermostat		,
   sTypeThermTemperature	=>	pTypeThermostat		,
   sTypeByronSX	=>	pTypeChime		,
   sTypeByronMP001	=>	pTypeChime		,
   sTypeSelectPlus	=>	pTypeChime		,
   sTypeSelectPlus3	=>	pTypeChime		,
   sTypeEnvivo	=>	pTypeChime		,
   sTypeTR1	=>	pTypeTEMP_RAIN		,
   sTypeBBQ1	=>	pTypeBBQ		,
   sTypeELEC5	=>	pTypePOWER		,
   sTypeLimitlessRGBW	=>	pTypeLimitlessLights		,
   sTypeLimitlessRGB	=>	pTypeLimitlessLights		,
   sTypeLimitlessWhite	=>	pTypeLimitlessLights		,
   sTypeRFY	=>	pTypeRFY		,
   sTypeRFYext	=>	pTypeRFY		,
   sTypeEvohome	=>	pTypeEvohome		,
   sTypeEvohomeZone	=>	pTypeEvohomeZone		,
   sTypeEvohomeWater	=>	pTypeEvohomeWater		,
   sTypeEvohomeRelay	=>	pTypeEvohomeRelay		,
   sSwitchTypeX10	=>	pTypeGeneralSwitch		,
   sSwitchTypeARC	=>	pTypeGeneralSwitch		,
   sSwitchTypeAB400D	=>	pTypeGeneralSwitch		,
   sSwitchTypeWaveman	=>	pTypeGeneralSwitch		,
   sSwitchTypeEMW200	=>	pTypeGeneralSwitch		,
   sSwitchTypeIMPULS	=>	pTypeGeneralSwitch		,
   sSwitchTypeRisingSun	=>	pTypeGeneralSwitch		,
   sSwitchTypePhilips	=>	pTypeGeneralSwitch		,
   sSwitchTypeEnergenie	=>	pTypeGeneralSwitch		,
   sSwitchTypeEnergenie5	=>	pTypeGeneralSwitch		,
   sSwitchTypeGDR2	=>	pTypeGeneralSwitch		,
   sSwitchTypeAC	=>	pTypeGeneralSwitch		,
   sSwitchTypeHEU	=>	pTypeGeneralSwitch		,
   sSwitchTypeANSLUT	=>	pTypeGeneralSwitch		,
   sSwitchTypeKoppla	=>	pTypeGeneralSwitch		,
   sSwitchTypePT2262	=>	pTypeGeneralSwitch		,
   sSwitchTypeLightwaveRF	=>	pTypeGeneralSwitch		,
   sSwitchTypeEMW100	=>	pTypeGeneralSwitch		,
   sSwitchTypeBBSB	=>	pTypeGeneralSwitch		,
   sSwitchTypeMDREMOTE	=>	pTypeGeneralSwitch		,
   sSwitchTypeRSL	=>	pTypeGeneralSwitch		,
   sSwitchTypeLivolo	=>	pTypeGeneralSwitch		,
   sSwitchTypeTRC02	=>	pTypeGeneralSwitch		,
   sSwitchTypeTRC02_2	=>	pTypeGeneralSwitch		,
   sSwitchTypeAoke	=>	pTypeGeneralSwitch		,
   sSwitchTypeEurodomest	=>	pTypeGeneralSwitch		,
   sSwitchTypeLivoloAppliance	=>	pTypeGeneralSwitch		,
   sSwitchTypeBlyss	=>	pTypeGeneralSwitch		,
   sSwitchTypeByronSX	=>	pTypeGeneralSwitch		,
   sSwitchTypeByronMP001	=>	pTypeGeneralSwitch		,
   sSwitchTypeSelectPlus	=>	pTypeGeneralSwitch		,
   sSwitchTypeSelectPlus3	=>	pTypeGeneralSwitch		
  }
  
  true;
RFXNAMES

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  $Try::Tiny::VERSION = '0.22';
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.22
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use strict;
use Plack::Runner;

my $runner = Plack::Runner->new;
$runner->parse_options(@ARGV);
$runner->run;

__END__

=head1 NAME

plackup - Run PSGI application with Plack servers

=head1 SYNOPSIS

  # read your app from app.psgi file
  plackup

  # choose .psgi file from ARGV[0] (or with -a option)
  plackup hello.psgi

  # switch server implementation with --server (or -s)
  plackup --server HTTP::Server::Simple --port 9090 --host 127.0.0.1 test.psgi

  # use UNIX socket to run FCGI daemon
  plackup -s FCGI --listen /tmp/fcgi.sock myapp.psgi

  # launch FCGI external server on port 9090
  plackup -s FCGI --port 9090

=head1 DESCRIPTION

plackup is a command line utility to run PSGI applications from the command
line.

plackup automatically figures out the environment it is run in, and
runs your application in that environment. FastCGI, CGI, AnyEvent and
others can all be detected. See L<Plack::Loader> for the authoritative
list.

C<plackup> assumes you have an C<app.psgi> script in your current directory.
The last statement of C<app.psgi> should be a code reference that is a PSGI
application:

  #!/usr/bin/perl
  use MyApp;
  my $application = MyApp->new;
  my $app = sub { $application->run_psgi(@_) };

=head1 ARGUMENTS

=over 4

=item .psgi

  plackup --host 127.0.0.1 --port 9090 /path/to/app.psgi

The first non-option argument is used as a C<.psgi> file path. You can
also set this path with C<-a> or C<--app>. If omitted, the
default file path is C<app.psgi> in the current directory.

=back

=head1 OPTIONS

=over 4

=item -a, --app

Specifies the full path to a C<.psgi> script. You may alternately provide this
path as the first argument to C<plackup>.

=item -e

Evaluates the given perl code as a PSGI app, much like perl's C<-e>
option:

  plackup -e 'sub { my $env = shift; return [ ... ] }'

It is also handy when you want to run a custom application like Plack::App::*.

  plackup -MPlack::App::File -e 'Plack::App::File->new(...)->to_app'

You can also specify C<-e> option with C<.psgi> file path to wrap the
application with middleware configuration from the command line. You
can also use L<Plack::Builder> DSL syntax inside C<-e> code. For example:

  plackup -e 'enable "Auth::Basic", authenticator => ...;' myapp.psgi

is equivalent to the PSGI application:

  use Plack::Builder;
  use Plack::Util;
  
  builder {
      enable "Auth::Basic", authenticator => ...;
      Plack::Util::load_psgi("myapp.psgi");
  };

Note that when you use C<-e> option to enable middleware, plackup
doesn't assume the implicit C<app.psgi> path. You must either pass the
path to your C<.psgi> file in the command line arguments or load the
application inside C<-e> after the C<enable>.

  plackup                                # Runs app.psgi
  plackup -e 'enable "Foo"'              # Doesn't work!
  plackup -e 'enable "Foo"' app.psgi     # Works
  plackup -e 'enable "Foo"; sub { ... }' # Works

=item -o, --host

Binds to a TCP interface. Defaults to undef, which lets most server backends
bind to the any (*) interface. This option is only valid for servers which support
TCP sockets.

=item -p, --port

Binds to a TCP port. Defaults to 5000. This option is only valid for servers
which support TCP sockets.

=item -s, --server, the C<PLACK_SERVER> environment variable

Selects a specific server implementation to run on. When provided, the C<-s> or
C<--server> flag will be preferred over the environment variable.

If no option is given, plackup will try to detect the I<best> server
implementation based on the environment variables as well as modules loaded by
your application in C<%INC>. See L<Plack::Loader> for details.

=item -S, --socket

Listens on a UNIX domain socket path. Defaults to undef. This option is only
valid for servers which support UNIX sockets.

=item -l, --listen

Listens on one or more addresses, whether "HOST:PORT", ":PORT", or "PATH"
(without colons). You may use this option multiple times to listen on multiple
addresses, but the server will decide whether it supports multiple interfaces.

=item -D, --daemonize

Makes the process run in the background. It's up to the backend server/handler
implementation whether this option is respected or not.

=item -I

Specifies Perl library include paths, like C<perl>'s -I option. You may add
multiple paths by using this option multiple times.

=item -M

Loads the named modules before loading the app's code. You may load multiple
modules by using this option multiple times.

=item -E, --env, the C<PLACK_ENV> environment variable.

Specifies the environment option. Setting this value with C<-E> or C<--env>
also writes to the C<PLACK_ENV> environment variable. This allows applications
or frameworks to tell which environment setting the application is running on.

  # These two are the same
  plackup -E deployment
  env PLACK_ENV=deployment plackup

Common values are C<development>, C<deployment>, and C<test>. The default value
is C<development>, which causes C<plackup> to load the middleware components:
I<AccessLog>, I<StackTrace>, and I<Lint> unless C<--no-default-middleware>
is set.

=item --no-default-middleware

This prevents loading the default middleware stack even when Plack
environment (i.e. C<-E> or C<PLACK_ENV>) is set to C<development>.

=item -r, --reload

Makes plackup restart the server whenever a file in your development directory
changes. This option by default watches the C<lib> directory and the base
directory where I<.psgi> file is located. Use C<-R> to watch other
directories.

Reloading will delay the compilation of your application. Automatic server
detection (see C<-s> above) may not behave as you expect, if plackup needs to
scan your application for the modules it uses. Avoid problems by specifying
C<-s> explicitly when using C<-r> or C<-R>.

=item -R, --Reload

Makes plackup restart the server whenever a file in any of the given
directories changes. C<-R> and C<--Reload> take a comma-separated list of
paths:

  plackup -R /path/to/project/lib,/path/to/project/templates

=item -L, --loader

Specifies the server loading subclass that implements how to run the server.
Available options are I<Plack::Loader> (default), I<Restarter> (automatically
set when C<-r> or C<-R> is used), I<Delayed>, and I<Shotgun>.

See L<Plack::Loader::Delayed> and L<Plack::Loader::Shotgun> for more details.

=item --access-log

Specifies the pathname of a file where the access log should be written.  By
default, in the development environment access logs will go to STDERR.

=item --path

Specify the root path of your app (C<SCRIPT_NAME> in PSGI env) to
run. The following two commands are roughly the same.

  plackup --path /foo app.psgi
  plackup -e 'mount "/foo" => Plack::Util::load_psgi("app.psgi")'

=back

Other options that starts with C<--> are passed through to the backend server.
See each Plack::Handler backend's documentation for more details on their
available options.

=head1 SEE ALSO

L<Plack::Runner> L<Plack::Loader>

=cut
